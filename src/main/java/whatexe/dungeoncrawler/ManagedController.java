package whatexe.dungeoncrawler;

import javafx.concurrent.Task;

import java.io.*;
import java.util.Map;

/**
 * A ManagedController is a special FXML controller that provides methods to the
 * {@link SceneManager} for setting its states. None of the method definitions need to be filled.
 * Definitions should only be as full as necessary for desired functionality. Some methods
 * introduce a Map of parameters that can be used to set the state of the extending controller.
 * If these parameters are not used at all, they can be ignored. They are useful for passing
 * non-static information between controllers, if needed. This potentially avoids the need for
 * {@link javafx.util.BuilderFactory}s and controller factories when loading FXML. It also avoids
 * the need to use static data that may have to be synchronized on.
 */
public abstract class ManagedController {

    /**
     * Should be implemented with a static inner subclass of SceneSaveData that contains the
     * information needed to serialize (save) and deserialize (load) the scene.
     */
    protected SceneSaveData saveData;

    /**
     * By default, calls {@link ManagedController#init(Map)} with no loadParameters.
     */
    public void init() {
        init(Map.of());
    }

    /**
     * Initializes the state of this ManagedController, with optional parameters to set the
     * initial state. This is unique from the constructor in that it can take in parameters
     *
     * @param loadParameters Parameters that can initialize the state of the scene. If the
     *                       extending controller does not need to use any passed loading
     *                       parameters, this parameter can be ignored.
     */
    public abstract void init(Map<String, ?> loadParameters);

    /**
     * Sets the state of this ManagedController, with parameters for setting the state.
     *
     * @param stateParameters Parameters that can set the state of this ManagedController. If the
     *                        extending controller does not need to use any passed state
     *                        parameters, this parameter can be ignored.
     */
    public abstract void setState(Map<String, ?> stateParameters);

    /**
     * Resets the state of this ManagedController.
     */
    public abstract void resetState();

    /**
     * Saves the state of this ManagedController to the specified location.
     *
     * @param location String path to save the state to.
     */
    public void saveState(String location) {
        if (saveData == null) {
            throw new RuntimeException("You must implement saveData with a static inner subclass "
                                               + "of SceneSaveData!");
        }
        if (saveData.getClass().isAssignableFrom(SceneSaveData.class)
                || saveData.getClass().isAnonymousClass()) {
            throw new RuntimeException("You must implement saveData with a static inner subclass "
                                               + "of SceneSaveData!");
        }
        Task<Void> saveTask = new Task<>() {
            @Override
            protected Void call() throws IOException {
                try (ObjectOutputStream outputStream =
                             new ObjectOutputStream(
                                     new BufferedOutputStream(new FileOutputStream(location)))) {
                    setSaveDataFromState();
                    outputStream.writeObject(saveData);
                } catch (IOException e) {
                    System.out.println("Failed to save state!");
                    throw e;
                }
                return null;
            }
        };

        Thread saveThread = new Thread(saveTask);
        saveThread.setDaemon(true);
        saveThread.start();
    }

    /**
     * Sets the state of this ManagedController from the {@link ManagedController#saveData}.
     * Called after deserialization in {@link ManagedController#loadState(String)}.
     */
    protected abstract void setSaveDataFromState();

    /**
     * Loads the state of this ManagedController from the specified location.
     *
     * @param location String path to save the state to.
     */
    public void loadState(String location) {
        if (saveData == null) {
            throw new RuntimeException("You must implement saveData with a static inner subclass "
                                               + "of SceneSaveData!");
        }
        if (saveData.getClass().isAssignableFrom(SceneSaveData.class)
                || saveData.getClass().isAnonymousClass()) {
            throw new RuntimeException("You must implement saveData with a static inner subclass "
                                               + "of SceneSaveData!");
        }
        Task<Void> loadTask = new Task<>() {
            @Override
            protected Void call() throws IOException, ClassNotFoundException {
                try (ObjectInputStream inputStream =
                             new ObjectInputStream(new FileInputStream(location))) {
                    saveData = saveData.getClass().cast(inputStream.readObject());
                    setStateFromSaveData();
                } catch (IOException | ClassNotFoundException e) {
                    System.out.println("Failed to load state! " + e.getLocalizedMessage());
                    throw e;
                }
                return null;
            }
        };

        Thread loadThread = new Thread(loadTask);
        loadThread.setDaemon(true);
        loadThread.start();
    }

    /**
     * Sets the {@link ManagedController#saveData} of this ManagedController from the current
     * state. Called before serialization in {@link ManagedController#saveState(String)}.
     */
    protected abstract void setStateFromSaveData();
}
