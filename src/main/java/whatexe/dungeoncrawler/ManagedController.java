package whatexe.dungeoncrawler;

import javafx.concurrent.Task;

import java.io.*;
import java.util.Map;

/**
 * A ManagedController is a special FXML controller that provides methods to the
 * {@link SceneManager} for setting its states. Only the {@link ManagedController#init()} method
 * needs to be defined. By default, most of the other method implementations are empty. Some methods
 * introduce a {@link Map} of parameters that can be used to set the state of the extending
 * controller. If these parameters are not used at all, they can be ignored. They are useful for
 * passing non-static information between controllers, if needed. This potentially avoids the
 * need for {@link javafx.util.BuilderFactory}s and controller factories when loading FXML. It
 * also avoids the need to use static data that may have to be synchronized on.
 * <br><br>
 * <strong>There needs to be a default, no-args constructor for a ManagedController!!!</strong>
 * <br><br>
 * If additional functionality is required for the ManagedController, certain methods should be
 * implemented: <br>
 * {@link ManagedController#setState(Map)}, <br>
 * {@link ManagedController#resetState()}, <br>
 * {@link ManagedController#setStateFromSaveData()}, <br>
 * {@link ManagedController#setSaveDataFromState()}. <br>
 * If these methods are not overridden, an {@link UnsupportedOperationException} will be thrown
 * when the methods are called.
 */
public abstract class ManagedController {

    /**
     * Should be implemented with a static inner subclass of SceneSaveData that contains the
     * information needed to serialize (save) and deserialize (load) the scene.
     */
    protected SceneSaveData saveData;

    /**
     * Initializes the state of this ManagedController.
     */
    public abstract void init();

    /**
     * Initializes the state of this ManagedController, with optional parameters to set the
     * initial state. This is unique from the constructor in that it can take in parameters. By
     * default, calls {@link ManagedController#init()}.
     *
     * @param loadParameters Parameters that can initialize the state of the scene. If the
     *                       extending controller does not need to use any passed loading
     *                       parameters, this parameter can be ignored.
     */
    public void init(Map<String, ?> loadParameters) {
        init();
    }

    /**
     * Sets the state of this ManagedController, with parameters for setting the state.
     *
     * @param stateParameters Parameters that can set the state of this ManagedController. If the
     *                        extending controller does not need to use any passed state
     *                        parameters, this parameter can be ignored.
     */
    public void setState(Map<String, ?> stateParameters) {
        throw new UnsupportedOperationException("This ManagedController doesn't support setting "
                                                        + "the state!");
    }

    /**
     * Resets the state of this ManagedController.
     */
    public void resetState() {
        throw new UnsupportedOperationException("This ManagedController doesn't support resetting "
                                                        + "the state!");
    }

    /**
     * Saves the state of this ManagedController to the specified location.
     *
     * @param location String path to save the state to.
     */
    public final void saveState(String location) {
        if (saveData == null) {
            throw new RuntimeException("You must implement saveData with a static inner subclass "
                                               + "of SceneSaveData!");
        }
        if (saveData.getClass().isAssignableFrom(SceneSaveData.class)
                || saveData.getClass().isAnonymousClass()) {
            throw new RuntimeException("You must implement saveData with a static inner subclass "
                                               + "of SceneSaveData!");
        }
        Task<Void> saveTask = new Task<>() {
            @Override
            protected Void call() throws IOException {
                try (ObjectOutputStream outputStream =
                             new ObjectOutputStream(
                                     new BufferedOutputStream(new FileOutputStream(location)))) {
                    setSaveDataFromState();
                    outputStream.writeObject(saveData);
                } catch (IOException e) {
                    System.out.println("Failed to save state!");
                    throw e;
                }
                return null;
            }
        };

        Thread saveThread = new Thread(saveTask);
        saveThread.setDaemon(true);
        saveThread.start();
    }

    /**
     * Sets the state of this ManagedController from the {@link ManagedController#saveData}.
     * Called after deserialization in {@link ManagedController#loadState(String)}.
     */
    protected void setSaveDataFromState() {
        throw new UnsupportedOperationException("This ManagedController doesn't support saving "
                                                        + "the state to a file!");
    }

    /**
     * Loads the state of this ManagedController from the specified location.
     *
     * @param location String path to save the state to.
     */
    public final void loadState(String location) {
        if (saveData == null) {
            throw new RuntimeException("You must implement saveData with a static inner subclass "
                                               + "of SceneSaveData!");
        }
        if (saveData.getClass().isAssignableFrom(SceneSaveData.class)
                || saveData.getClass().isAnonymousClass()) {
            throw new RuntimeException("You must implement saveData with a static inner subclass "
                                               + "of SceneSaveData!");
        }
        Task<Void> loadTask = new Task<>() {
            @Override
            protected Void call() throws IOException, ClassNotFoundException {
                try (ObjectInputStream inputStream =
                             new ObjectInputStream(new FileInputStream(location))) {
                    saveData = saveData.getClass().cast(inputStream.readObject());
                    setStateFromSaveData();
                } catch (IOException | ClassNotFoundException e) {
                    System.out.println("Failed to load state! " + e.getLocalizedMessage());
                    throw e;
                }
                return null;
            }
        };

        Thread loadThread = new Thread(loadTask);
        loadThread.setDaemon(true);
        loadThread.start();
    }

    /**
     * Sets the {@link ManagedController#saveData} of this ManagedController from the current
     * state. Called before serialization in {@link ManagedController#saveState(String)}.
     */
    protected void setStateFromSaveData() {
        throw new UnsupportedOperationException("This ManagedController doesn't support loading "
                                                        + "the state from a file!");
    }
}
