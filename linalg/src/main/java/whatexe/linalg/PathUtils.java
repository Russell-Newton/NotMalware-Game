package whatexe.linalg;

import javafx.geometry.Bounds;
import javafx.scene.shape.*;

import java.util.Arrays;
import java.util.function.Consumer;

import static whatexe.linalg.Vector.EPSILON;

public class PathUtils {

    public static Line getIntersectionEdgeClosestToPoint(Path intersection, Vector point) {
        double[] closestDistance = {0};
        Line[] closest = {null};

        forEachPathLine(intersection, line -> {
            double distance = line.distanceToPoint(point);
            if (closest[0] == null || distance < closestDistance[0]) {
                closestDistance[0] = distance;
                closest[0] = line;
            }
        });

        return closest[0];
    }

    public static void forEachPathLine(Path path, Consumer<Line> lineAction) {
        Vector start = new Vector(0, 0);
        Vector previous = new Vector(0, 0);

        for (PathElement element : path.getElements()) {
            Line newLine;
            if (element instanceof MoveTo) {
                MoveTo to = (MoveTo) element;
                start = new Vector(to.getX(), to.getY());
                previous = start;
                continue;
            } else if (element instanceof LineTo) {
                LineTo to = (LineTo) element;
                Vector next = new Vector(to.getX(), to.getY());
                newLine = new Line(previous, next);

                previous = next;
            } else if (element instanceof ClosePath) {
                newLine = new Line(previous, start);

                previous = start;
            } else {
                continue;
            }

            if (newLine.getStart().isAlmost(newLine.getEnd())) {
                continue;
            }

            lineAction.accept(newLine);
        }
    }

    public static Vector findPushVector(Vector hitboxCenter,
                                        Path hitBoxOverlap) {
        double[] maxOverlaps = {0, 0};

        System.out.println();
        System.out.println(hitBoxOverlap);

        PathUtils.forEachPathLine(hitBoxOverlap, line -> {
            Vector centerToMidpoint = line.midpoint().minus(hitboxCenter);
            Vector normal = line.normal();

            // if (centerToMidpoint.get(0) != 0 && Math.abs(maxOverlaps[1]) < length) {
            //     maxOverlaps[1] = length * Math.signum(centerToMidpoint.get(1));
            // }
            // if (centerToMidpoint.get(1) != 0 && Math.abs(maxOverlaps[0]) < length) {
            //     maxOverlaps[0] = length * Math.signum(centerToMidpoint.get(0));
            // }
            if (Math.abs(centerToMidpoint.angleTo(normal) % Math.PI / 2) > EPSILON) {
                Vector tangent = line.tangent();
                if (tangent.dot(centerToMidpoint) > 0) {
                    tangent = tangent.scaledBy(-1);
                }
                if (Math.abs(maxOverlaps[0]) < Math.abs(tangent.get(0))) {
                    maxOverlaps[0] = tangent.get(0);
                }
                if (Math.abs(maxOverlaps[1]) < Math.abs(tangent.get(1))) {
                    maxOverlaps[1] = tangent.get(1);
                }
            }
            System.out.println(Math.abs(centerToMidpoint.angleTo(normal) % Math.PI / 2)
                                       + " " + normal
                                       + " " + hitboxCenter
                                       + " " + centerToMidpoint
                                       + " " + line
                                       + " " + Arrays.toString(maxOverlaps));
        });
        return new Vector(maxOverlaps[0], maxOverlaps[1]);
    }

    public static Vector getConstrainedVelocity(Bounds hitboxBounds,
                                                Path constraints,
                                                Vector attemptVelocity) {
        Vector constrainedVelocity = new Vector(0, 0);

        Bounds previousHitboxBounds = hitboxBounds;

        Shape predictedHitbox = new Rectangle(hitboxBounds.getWidth(), hitboxBounds.getHeight());
        predictedHitbox.setTranslateX(previousHitboxBounds.getMinX() + attemptVelocity.get(0));
        predictedHitbox.setTranslateY(previousHitboxBounds.getMinY() + attemptVelocity.get(1));
        predictedHitbox.applyCss();

        Shape predictedOverlap = Shape.intersect(predictedHitbox, constraints);
        predictedOverlap.applyCss();

        if (predictedOverlap.getLayoutBounds().getWidth() <= EPSILON
                && predictedOverlap.getLayoutBounds().getHeight() <= EPSILON) {
            return attemptVelocity;
        }

        int attempts = 0;

        while (predictedOverlap.getLayoutBounds().getWidth() > EPSILON
                && predictedOverlap.getLayoutBounds().getHeight() > EPSILON
                && attempts < 5
                && !attemptVelocity.isZero()) {

            // Cast rays to predicted corners, find intersections
            Vector topLeft = new Vector(previousHitboxBounds.getMinX(),
                                        previousHitboxBounds.getMinY());
            Vector topRight = new Vector(previousHitboxBounds.getMaxX(),
                                         previousHitboxBounds.getMinY());
            Vector bottomRight = new Vector(previousHitboxBounds.getMaxX(),
                                            previousHitboxBounds.getMaxY());
            Vector bottomLeft = new Vector(previousHitboxBounds.getMinX(),
                                           previousHitboxBounds.getMaxY());
            Vector[] currentCorners = {topLeft, topRight, bottomRight, bottomLeft};

            Line topLeftCast = new Line(topLeft, topLeft.plus(attemptVelocity));
            Line topRightCast = new Line(topRight, topRight.plus(attemptVelocity));
            Line bottomRightCast = new Line(bottomRight, bottomRight.plus(attemptVelocity));
            Line bottomLeftCast = new Line(bottomLeft, bottomLeft.plus(attemptVelocity));
            Line[] casts = {topLeftCast, topRightCast, bottomRightCast, bottomLeftCast};

            double[] distances = {-1, -1, -1, -1};
            Vector[] intersections = new Vector[4];
            Vector[] normals = new Vector[4];

            Vector temporaryAttemptVelocity = attemptVelocity;
            forEachPathLine(constraints, line -> {
                for (int i = 0; i < 4; i++) {
                    Vector intersect = casts[i].intersectionWith(line);
                    if (intersect != null) {
                        double distance = currentCorners[i].distanceTo(intersect);
                        if (intersections[i] == null || distances[i] > distance) {
                            intersections[i] = intersect;
                            distances[i] = distance;

                            Vector normal = line.normal();
                            if (normal.dot(temporaryAttemptVelocity) > 0) {
                                // Normal facing inside isn't good
                                normals[i] = normal.scaledBy(-1);
                            } else {
                                normals[i] = normal;
                            }
                        }
                    }
                }
            });

            Vector constrainedPerpendicular = null;
            Vector parallel = null;
            double minDistance = 0;
            for (int i = 0; i < 4; i++) {
                if (intersections[i] != null && (constrainedPerpendicular == null
                        || distances[i] < minDistance)) {
                    minDistance = distances[i];

                    Vector upToLine = casts[i].tangent().unit().scaledBy(distances[i] - EPSILON);
                    constrainedPerpendicular = Line.projectVector(normals[i], upToLine);

                    parallel = Line.projectVector(upToLine.minus(constrainedPerpendicular),
                                                  attemptVelocity);
                }
            }

            if (constrainedPerpendicular == null) {
                // intersection is on a strange corner that intersects a hitbox edge
                // System.out.println("Strange intersection!");
                return constrainedVelocity;
            }

            if (constrainedPerpendicular.containsNaN() || constrainedPerpendicular.isZero()) {
                constrainedPerpendicular = new Vector(0, 0);
            }
            if (parallel.containsNaN() || parallel.isZero()) {
                parallel = new Vector(0, 0);
            }

            constrainedVelocity = constrainedVelocity.plus(constrainedPerpendicular);
            attemptVelocity = parallel;

            predictedHitbox.setTranslateX(
                    previousHitboxBounds.getMinX() + constrainedPerpendicular.get(0)
                            + attemptVelocity.get(0));
            predictedHitbox.setTranslateY(
                    previousHitboxBounds.getMinY() + constrainedPerpendicular.get(1)
                            + attemptVelocity.get(1));
            predictedHitbox.applyCss();

            previousHitboxBounds = predictedHitbox.getBoundsInParent();

            predictedOverlap = Shape.intersect(predictedHitbox, constraints);
            predictedOverlap.applyCss();

            attempts++;
        }

        return constrainedVelocity.plus(attemptVelocity);
    }
}
