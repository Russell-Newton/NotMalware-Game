package whatexe.linalg;

import javafx.scene.shape.*;

import java.util.Objects;
import java.util.function.Consumer;

public class Line {
    private final Vector start;
    private final Vector end;

    public Line(Vector start, Vector end) {
        assert start.size() == end.size() && start.size() == 2;
        this.start = start;
        this.end = end;
    }

    public static Line getIntersectionEdgeClosestToPoint(Path intersection, Vector point) {
        double[] closestDistance = {0};
        Line[] closest = {null};

        forEachPathLine(intersection, line -> {
            double distance = line.distanceToPoint(point);
            if (closest[0] == null || distance < closestDistance[0]) {
                closestDistance[0] = distance;
                closest[0] = line;
            }
        });

        return closest[0];
    }

    public static void forEachPathLine(Path path, Consumer<Line> lineAction) {
        Vector start = new Vector(0, 0);
        Vector previous = new Vector(0, 0);

        for (PathElement element : path.getElements()) {
            Line newLine;
            if (element instanceof MoveTo) {
                MoveTo to = (MoveTo) element;
                start = new Vector(to.getX(), to.getY());
                previous = start;
                continue;
            } else if (element instanceof LineTo) {
                LineTo to = (LineTo) element;
                Vector next = new Vector(to.getX(), to.getY());
                newLine = new Line(previous, next);

                previous = next;
            } else if (element instanceof ClosePath) {
                newLine = new Line(previous, start);

                previous = start;
            } else {
                continue;
            }

            if (newLine.start.isAlmost(newLine.end)) {
                continue;
            }

            lineAction.accept(newLine);
        }
    }

    public double distanceToPoint(Vector point) {
        return Line.distanceToPoint(this, point);
    }

    public static double distanceToPoint(Line line, Vector point) {
        assert point.size() == 2;

        Vector dStartEnd = line.tangent();   // end - start
        Vector dStartPoint = point.minus(line.start);    // point - start
        Vector dEndStart = dStartEnd.scaledBy(-1);   // start - end
        Vector dEndPoint = point.minus(line.end);        // point - end

        double aStartToPoint = dStartEnd.angleTo(dStartPoint);
        double aEndToPoint = dEndStart.angleTo(dEndPoint);
        if (aStartToPoint > Math.PI / 2) {
            // past start of the line
            return Math.abs(point.distance(line.start));
        }
        if (aEndToPoint > Math.PI / 2) {
            // past end of the line
            return Math.abs(point.distance(line.end));
        }

        return Math.abs(dStartEnd.get(0) * dStartPoint.get(1)
                                - dStartEnd.get(1) * dStartPoint.get(0))
                / dStartEnd.magnitude();
    }

    public Vector midpoint() {
        return Line.midpoint(this);
    }

    public static Vector midpoint(Line line) {
        return line.start.plus(line.end.plus(line.start.scaledBy(-1)).scaledBy(0.5));
    }

    public Vector projectVector(Vector vector) {
        return Line.projectVector(this, vector);
    }

    public static Vector projectVector(Line line, Vector vector) {
        Vector lineVector = line.tangent();

        return lineVector.scaledBy(vector.dot(lineVector) / lineVector.dot(lineVector));
    }

    public Vector tangent() {
        return Line.tangent(this);
    }

    public static Vector tangent(Line line) {
        return line.end.minus(line.start);
    }

    public Vector normal() {
        return Line.normal(this);
    }

    public static Vector normal(Line line) {
        Vector tangent = line.tangent();
        return new Vector(tangent.get(1), tangent.get(0));
    }

    public double length() {
        return Line.length(this);
    }

    public static double length(Line line) {
        return line.tangent().magnitude();
    }

    @Override
    public int hashCode() {

        return Objects.hash(start, end);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Line line = (Line) o;
        return Objects.equals(start, line.start) && Objects.equals(end, line.end);
    }

    @Override
    public String toString() {
        return "Line{" + "start=" + start + ", end=" + end + '}';
    }
}
