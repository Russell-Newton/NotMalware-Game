package whatexe.linalg;

import javafx.scene.shape.Path;

import java.util.Arrays;
import java.util.function.IntConsumer;
import java.util.stream.IntStream;

public class Vector {

    private static final double EPSILON = 1e-3;

    private final double[] v;

    public Vector(Vector other) {
        this(other.v);
    }

    public Vector(double... v) {
        this.v = v;
    }

    public static Vector scalarProduct(Vector vector, double scalar) {
        double[] product = new double[vector.size()];
        operate(vector.size(), i -> product[i] = vector.get(i) * scalar);

        return new Vector(product);
    }

    public static Vector normal(Vector vector) {
        assert !vector.isZero();

        return vector.scaledBy(1 / vector.magnitude());
    }

    public static Vector findPushVector(Vector hitboxCenter,
                                        Path hitBoxOverlap) {
        double[] maxOverlaps = {0, 0};

        System.out.println();
        System.out.println(hitBoxOverlap);

        Line.forEachPathLine(hitBoxOverlap, line -> {
            Vector centerToMidpoint = line.midpoint().minus(hitboxCenter);
            Vector normal = line.normal();

            // if (centerToMidpoint.get(0) != 0 && Math.abs(maxOverlaps[1]) < length) {
            //     maxOverlaps[1] = length * Math.signum(centerToMidpoint.get(1));
            // }
            // if (centerToMidpoint.get(1) != 0 && Math.abs(maxOverlaps[0]) < length) {
            //     maxOverlaps[0] = length * Math.signum(centerToMidpoint.get(0));
            // }
            if (Math.abs(centerToMidpoint.angleTo(normal) % Math.PI / 2) > EPSILON) {
                Vector tangent = line.tangent();
                if (tangent.dot(centerToMidpoint) > 0) {
                    tangent = tangent.scaledBy(-1);
                }
                if (Math.abs(maxOverlaps[0]) < Math.abs(tangent.get(0))) {
                    maxOverlaps[0] = tangent.get(0);
                }
                if (Math.abs(maxOverlaps[1]) < Math.abs(tangent.get(1))) {
                    maxOverlaps[1] = tangent.get(1);
                }
            }
            System.out.println(Math.abs(centerToMidpoint.angleTo(normal) % Math.PI / 2)
                                       + " " + normal
                                       + " " + hitboxCenter
                                       + " " + centerToMidpoint
                                       + " " + line
                                       + " " + Arrays.toString(maxOverlaps));
        });
        return new Vector(maxOverlaps[0], maxOverlaps[1]);
    }

    public static double dotProduct(Vector u1, Vector u2) {
        assertSameLengths(u1, u2);

        double[] sum = new double[1];
        operate(u1.size(), i -> sum[0] += u1.get(i) * u2.get(i));

        return sum[0];
    }

    public static double angleBetween(Vector u1, Vector u2) {
        assertSameLengths(u1, u2);

        double val = Vector.dotProduct(u1, u2) / (u1.magnitude() * u2.magnitude());

        return Math.acos(val);
    }

    public double[] getV() {
        return v;
    }

    public Vector plus(Vector other) {
        return Vector.sum(this, other);
    }

    public static Vector sum(Vector u1, Vector u2) {
        assertSameLengths(u1, u2);

        double[] sum = new double[u1.size()];
        operate(u1.size(), i -> sum[i] = u1.get(i) + u2.get(i));

        return new Vector(sum);
    }

    private static void assertSameLengths(Vector... vectors) {
        operate(vectors.length, i -> {
            assert vectors[i].size() == vectors[0].size();
        });
    }

    public int size() {
        return v.length;
    }

    private static void operate(int count, IntConsumer operator) {
        IntStream.range(0, count).forEach(operator);
    }

    public double get(int pos) {
        return v[pos];
    }

    public Vector scaledBy(double scalar) {
        return Vector.scalarProduct(this, scalar);
    }

    public double dot(Vector other) {
        return Vector.dotProduct(this, other);
    }

    public boolean isZero() {
        return powerSum(this, 2) > EPSILON;
    }

    public Vector normal() {
        return Vector.normal(this);
    }

    public double angleTo(Vector other) {
        return angleBetween(this, other);
    }

    public double pnorm(double p) {
        return Vector.pnorm(this, p);
    }

    public static double pnorm(Vector vector, double p) {
        return Math.pow(powerSum(vector, p), 1 / p);
    }

    public static double powerSum(Vector vector, double p) {
        assert p >= 1;

        double[] sum = new double[1];
        operate(vector.size(), i -> sum[0] += Math.pow(Math.abs(vector.get(i)), p));

        return sum[0];
    }

    public Vector entrywiseProduct(Vector other) {
        return Vector.entrywiseProduct(this, other);
    }

    public static Vector entrywiseProduct(Vector u1, Vector u2) {
        assertSameLengths(u1, u2);

        double[] product = new double[u1.size()];
        operate(product.length, i -> product[i] = u1.get(i) * u2.get(i));

        return new Vector(product);
    }

    public double distance(Vector other) {
        return Vector.distance(this, other);
    }

    public static double distance(Vector u1, Vector u2) {
        Vector difference = u2.minus(u1);

        return difference.magnitude();
    }

    public Vector minus(Vector other) {
        return Vector.difference(this, other);
    }

    public double magnitude() {
        return Vector.pnorm(this, 2);
    }

    public static Vector difference(Vector u1, Vector u2) {
        assertSameLengths(u1, u2);

        double[] difference = new double[u1.size()];
        operate(u1.size(), i -> difference[i] = u1.get(i) - u2.get(i));

        return new Vector(difference);
    }

    public boolean isAlmost(Vector other) {
        return Vector.areCloseEnough(this, other);
    }

    public static boolean areCloseEnough(Vector u1, Vector u2) {
        return distance(u1, u2) < EPSILON;
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(v);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Vector vector = (Vector) o;
        return Arrays.equals(v, vector.v);
    }

    @Override
    public String toString() {
        return "Vector" + Arrays.toString(v);
    }
}
