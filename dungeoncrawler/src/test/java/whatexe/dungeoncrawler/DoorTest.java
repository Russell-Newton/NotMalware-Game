package whatexe.dungeoncrawler;

import javafx.application.Platform;
import javafx.collections.ObservableList;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseButton;
import javafx.stage.Stage;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.testfx.api.FxToolkit;
import org.testfx.framework.junit5.ApplicationTest;
import whatexe.dungeoncrawler.controllers.LevelController;
import whatexe.dungeoncrawler.entities.doors.Door;
import whatexe.dungeoncrawler.layout.Direction;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class DoorTest extends ApplicationTest {
    @Override
    public void start(Stage stage) throws Exception {
        MainApp mainApp = new MainApp();
        mainApp.start(stage);

        stage.toFront();
    }

    @BeforeEach
    public void startUp() throws IOException {
        interact(() -> {
            try {
                MainApp.switchScene("Configuration");
                MainApp.switchScene("Level", Map.of(
                        "difficulty", Difficulty.NORMAL,
                        "name", "Burdell",
                        "weapon", WeaponType.MELEE,
                        "seed", 5));
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
    }

    @AfterEach
    public void tearDown() throws Exception {
        FxToolkit.hideStage();
        release(new KeyCode[]{});
        release(new MouseButton[]{});
        SceneManager.getInstance().clear();
    }

    @Test
    public void doorUnlockingTest() throws IOException, InterruptedException {
        Thread.sleep(5000);
        LevelController levelController =
                (LevelController) SceneManager.getInstance().getSceneController("Level");
        Platform.runLater(() -> {
            Direction[] cardinalDirections = {Direction.UP, Direction.LEFT, Direction.RIGHT, Direction.DOWN};
            for(Direction direction : cardinalDirections){
                levelController.getLevel().move(direction);
                ObservableList<Door> roomDoors = levelController.getCurrentRoom().getDoors();
                checkDoorsAreLocked(roomDoors, direction.getOpposite());
                levelController.getCurrentRoom().getEnemies().clear();
                checkDoorsAreUnlocked(roomDoors);
                levelController.getLevel().move(direction.getOpposite());
            }
        });
    }

    private void checkDoorsAreLocked(ObservableList<Door> doors, Direction... excludeDirections) {
        for(Door door : doors) {
            if (Arrays.asList(excludeDirections).contains(door.getDirection())) {
                continue;
            }
            assertTrue(door.isLocked());
        }
    }

    private void checkDoorsAreUnlocked(ObservableList<Door> doors, Direction... excludeDirections) {
        for(Door door : doors) {
            if (Arrays.asList(excludeDirections).contains(door.getDirection())) {
                continue;
            }
            assertFalse(door.isLocked());
        }
    }

    @Test
    public void visitedRoomDoorsUnlockedTest() {

    }


}
