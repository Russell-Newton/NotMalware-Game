package whatexe.dungeoncrawler.layout.generation;


import whatexe.dungeoncrawler.Difficulty;
import whatexe.dungeoncrawler.layout.Direction;
import whatexe.dungeoncrawler.layout.Level;
import whatexe.dungeoncrawler.layout.RoomChoices;

import java.util.*;


public class SimpleLevelGenerator implements LevelGenerator {

    // Constants for calculating when to pivot the crawling direction
    private static final double PIVOT_CHANCE_SCALE = 1;
    private static final double PIVOT_CHANCE_SHIFT_UP = 0.75;
    private static final double PIVOT_CHANCE_SHIFT_RIGHT = 4.5;

    // Constants for calculating when to create a dead end
    private static final double DEAD_END_CHANCE_BASE = 1.6;
    private static final double DEAD_END_CHANCE_SCALE = 3;

    // Constants for calculating when to create a boss room
    private static final int MIN_BOSS_DEPTH = 6;
    private static final double BOSS_ROOM_SCALE = 8;

    // Constants for determining when to add rooms
    private static final int MAX_ROOMS = 15;
    private static final double ADD_ROOM_CHANCE = 0.65;
    private static final double CLUMP_CHANCE = 0.25;

    private static final int MAX_NUM_CHALLENGE_ROOMS = 1;

    private final Random randomizer;
    private final RoomPosition startingPosition = new RoomPosition(0, 0);
    private final RoomChoices roomChoices;
    private final Difficulty difficulty;

    // Generated by generate()
    private Level level;
    private RoomPosition bossRoomPosition;
    private RoomPosition shopPosition;
    private Set<RoomPosition> rooms;
    private Set<RoomPosition> deadEnds;


    public SimpleLevelGenerator(Difficulty difficulty) {
        this(difficulty, RoomChoices.STANDARD);
    }

    public SimpleLevelGenerator(Difficulty difficulty, RoomChoices roomChoices) {
        randomizer = new Random();
        this.difficulty = difficulty;
        this.roomChoices = roomChoices;
    }

    public SimpleLevelGenerator(Difficulty difficulty, long seed) {
        this(difficulty, RoomChoices.STANDARD, seed);
    }

    public SimpleLevelGenerator(Difficulty difficulty, RoomChoices roomChoices, long seed) {
        randomizer = new Random(seed);
        this.difficulty = difficulty;
        this.roomChoices = roomChoices;
    }

    /**
     * Used to determine if the current room should be a dead end.
     * Based on an exponential function, set up with constants
     * {@link SimpleLevelGenerator#MAX_ROOMS},
     * {@link SimpleLevelGenerator#DEAD_END_CHANCE_SCALE}, and
     * {@link SimpleLevelGenerator#DEAD_END_CHANCE_BASE}.
     *
     * @param randomizer randomizer, so a seed can be used.
     * @param depth      current room depth.
     * @return if the current room should be a dead end.
     */
    private static boolean shouldBeDeadEnd(Random randomizer, int depth) {
        double y = (DEAD_END_CHANCE_SCALE / MAX_ROOMS) * Math.pow(DEAD_END_CHANCE_BASE, depth);
        double check = randomizer.nextDouble();
        return check < y;
    }

    /**
     * Used to determine if the current room should be the boss room.
     * Based on a linear function, set up with constants
     * {@link SimpleLevelGenerator#MAX_ROOMS},
     * {@link SimpleLevelGenerator#MIN_BOSS_DEPTH}, and
     * {@link SimpleLevelGenerator#BOSS_ROOM_SCALE}.
     *
     * @param randomizer randomizer, so a seed can be used.
     * @param depth      current room depth.
     * @return if the current room should be a boss room.
     */
    private static boolean shouldBeBossRoom(Random randomizer, int depth) {
        double y = (BOSS_ROOM_SCALE / MAX_ROOMS) * (depth - (MIN_BOSS_DEPTH - 1));
        double check = randomizer.nextDouble();
        return check < y;
    }

    /**
     * Used to determine if the primary crawl direction should change.
     * Based on a negative quadratic function, set up with constants
     * {@link SimpleLevelGenerator#MAX_ROOMS},
     * {@link SimpleLevelGenerator#PIVOT_CHANCE_SCALE},
     * {@link SimpleLevelGenerator#PIVOT_CHANCE_SHIFT_UP}, and
     * {@link SimpleLevelGenerator#PIVOT_CHANCE_SHIFT_RIGHT}.
     *
     * @param randomizer randomizer, so a seed can be used.
     * @param depth      current room depth.
     * @return if the primary crawl direction should pivot.
     */
    private static boolean shouldPivot(Random randomizer, int depth) {
        double y =
                -(1.0 / (MAX_ROOMS * PIVOT_CHANCE_SCALE))
                        * Math.pow((depth - PIVOT_CHANCE_SHIFT_RIGHT), 2)
                        + PIVOT_CHANCE_SHIFT_UP;
        double check = randomizer.nextDouble();
        return check < y;
    }

    private static <T> Set<T> setIntersection(Set<T> a, Set<T> b) {
        Set<T> c = new HashSet<>();
        for (T t : a) {
            if (b.contains(t)) {
                c.add(t);
            }
        }

        return c;
    }

    @Override
    public Level generate() {
        return generate(0);
    }

    @Override
    public Level generate(int depth) {
        bossRoomPosition = null;
        rooms = new HashSet<>();
        deadEnds = new HashSet<>();
        level = new Level(difficulty, depth);

        List<Direction> directionOptions = new ArrayList<>(Arrays.asList(Direction.values()));

        // Randomly choose order of crawling to start
        Direction[] startCrawlDirections = new Direction[4];
        for (int i = 0; i < startCrawlDirections.length; i++) {
            int next = randomizer.nextInt(directionOptions.size());
            startCrawlDirections[i]
                    = directionOptions.remove(next);
        }

        rooms.add(startingPosition);
        for (Direction direction : startCrawlDirections) {
            crawl(direction, direction, startingPosition.getNeighbor(direction));
        }

        initRooms();

        return level;
    }

    private void crawl(Direction primaryDirection,
                       Direction currentDirection,
                       RoomPosition currentPosition) {
        rooms.add(currentPosition);
        if (rooms.size() >= MAX_ROOMS || deadEnds.contains(currentPosition)) {
            return;
        }

        if (shouldPivot(randomizer, currentPosition.distance(startingPosition))) {
            Direction option1 = currentDirection.getCCW();
            Direction option2 = currentDirection.getCW();

            // Avoid looping back
            if (option1 == primaryDirection.getOpposite()) {
                option1 = currentDirection;
            }
            if (option2 == primaryDirection.getOpposite()) {
                option2 = currentDirection;
            }

            // Avoid clusters
            if (neighbors(currentPosition.getNeighbor(option1),
                          Set.of(option1.getOpposite())).size() > 0) {
                option1 = currentDirection;
            }
            if (neighbors(currentPosition.getNeighbor(option2),
                          Set.of(option2.getOpposite())).size() > 0) {
                option2 = currentDirection;
            }

            // Change direction
            boolean check = randomizer.nextBoolean();
            if (check) {
                currentDirection = option1;
            } else {
                currentDirection = option2;
            }
        }

        // Primary crawl
        if (bossRoomPosition == null) {
            RoomPosition neighbor = currentPosition.getNeighbor(currentDirection);
            if (shouldBeBossRoom(randomizer, neighbor.distance(startingPosition))) {
                bossRoomPosition = neighbor;
                shopPosition = currentPosition;
                deadEnds.add(bossRoomPosition);
            }
            crawl(primaryDirection, currentDirection, neighbor);
        }

        for (Direction direction : new Direction[]{currentDirection,
                currentDirection.getCCW(),
                currentDirection.getCW()}) {

            RoomPosition nextPosition = currentPosition.getNeighbor(direction);
            if (rooms.contains(nextPosition)) {
                continue;
            }

            Set<RoomPosition> futureNeighbors = neighbors(nextPosition,
                                                          Set.of(direction.getOpposite()));

            // Check if room should be added in the first place
            double check = randomizer.nextDouble();
            boolean addRoom = check < ADD_ROOM_CHANCE;
            // Check for clumps... if clump isn't acceptable, remove
            check = randomizer.nextDouble();
            if (futureNeighbors.size() > 0 && check > CLUMP_CHANCE) {
                addRoom = false;
            }
            addRoom &= setIntersection(futureNeighbors, deadEnds).size() == 0;

            // Create dead end if desired
            if (addRoom) {
                if (shouldBeDeadEnd(randomizer, nextPosition.distance(startingPosition))) {
                    deadEnds.add(nextPosition);
                    rooms.add(nextPosition);
                } else {
                    crawl(primaryDirection, direction, nextPosition);
                }
            }
        }
    }


    private Set<RoomPosition> neighbors(RoomPosition queryPosition,
                                        Set<Direction> excludeDirections) {
        Set<RoomPosition> neighbors = new HashSet<>();
        Set<Direction> directions = new HashSet<>(Arrays.asList(Direction.values()));
        directions.removeAll(excludeDirections);
        for (Direction direction : directions) {
            RoomPosition neighbor = queryPosition.getNeighbor(direction);
            if (rooms.contains(neighbor)) {
                neighbors.add(neighbor);
            }
        }
        return neighbors;
    }

    private void initRooms() {
        // reset dead ends
        deadEnds = new HashSet<>();
        int numChallengeRooms = 0;

        for (RoomPosition position : rooms) {
            Set<Direction> exits = new HashSet<>();
            for (Direction direction : Direction.values()) {
                if (rooms.contains(position.getNeighbor(direction))) {
                    exits.add(direction);
                }
            }

            level.getMaze().put(position,
                                roomChoices.getOrdinaryRoom(level,
                                                            exits.toArray(Direction[]::new)));

            if (exits.size() == 1) {
                deadEnds.add(position);
                boolean shouldBeChallengeRoom = randomizer.nextBoolean();
                if (shouldBeChallengeRoom && numChallengeRooms < MAX_NUM_CHALLENGE_ROOMS) {
                    level.getMaze().put(
                            position,
                            roomChoices.getChallengeRoom(level,
                                                         exits.toArray(Direction[]::new)));
                    numChallengeRooms++;
                }
            }

            if (position.equals(bossRoomPosition)) {
                level.getMaze().put(position,
                                    roomChoices.getBossRoom(level,
                                                            exits.toArray(Direction[]::new)[0]));
            } else if (position.equals(shopPosition)) {
                level.getMaze().put(position,
                                    roomChoices.getShopRoom(level,
                                                            exits.toArray(Direction[]::new)));
            } else if (position.equals(startingPosition)) {
                level.getMaze().put(position,
                                    roomChoices.getStartingRoom(level));
            }
        }
    }

    public RoomPosition getStartingPosition() {
        return startingPosition;
    }

    public Level getLevel() {
        return level;
    }

    public RoomPosition getBossRoomPosition() {
        return bossRoomPosition;
    }

    public Set<RoomPosition> getRooms() {
        return rooms;
    }

    public Set<RoomPosition> getDeadEnds() {
        return deadEnds;
    }
}
