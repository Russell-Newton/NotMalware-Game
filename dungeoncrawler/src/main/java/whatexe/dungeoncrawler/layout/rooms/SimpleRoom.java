package whatexe.dungeoncrawler.layout.rooms;

import javafx.collections.ListChangeListener;
import javafx.event.EventHandler;
import javafx.scene.control.Button;
import javafx.scene.input.KeyEvent;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.Shape;
import whatexe.dungeoncrawler.MainApp;
import whatexe.dungeoncrawler.entities.doors.SimpleDoor;
import whatexe.dungeoncrawler.entities.enemies.BigDamageEnemy;
import whatexe.dungeoncrawler.entities.enemies.Enemy;
import whatexe.dungeoncrawler.entities.enemies.MeleeEnemy;
import whatexe.dungeoncrawler.entities.enemies.ShieldEnemy;
import whatexe.dungeoncrawler.entities.motionsupport.Vector;
import whatexe.dungeoncrawler.layout.Direction;
import whatexe.dungeoncrawler.layout.Level;
import whatexe.tileengine.MapObject;
import whatexe.tileengine.TiledMap;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class SimpleRoom extends Room {

    private static final int MAX_MONSTERS = 4;
    private static final int POSSIBLE_ENEMIES = 3;

    public SimpleRoom(TiledMap fromTiledMap,
                      Level owningLevel,
                      Direction... exitDirections) {
        super(fromTiledMap, owningLevel, exitDirections);
    }

    @Override
    protected void initDoors(Direction[] directionsToGenerate) {
        List<MapObject> doorMapObject = fromTiledMap.getObjectGroups().get("Doors").getObjects();
        Collections.sort(doorMapObject, new MapObjectComparator());

        for (Direction direction : directionsToGenerate) {
            MapObject correspondingDoor;
            Button button = new Button(direction.toString());

            correspondingDoor = doorMapObject.get(direction.ordinal());
            button.setOnAction(event -> owningLevel.move(direction));

            button.setId(direction.toString());
            button.setTranslateX(correspondingDoor.getX());
            button.setTranslateY(correspondingDoor.getY());
            button.setPrefWidth(correspondingDoor.getWidth());
            button.setPrefHeight(correspondingDoor.getHeight());
            button.applyCss();

            Shape hitbox = new Rectangle(correspondingDoor.getWidth() + 0.1,
                                         correspondingDoor.getHeight() + 0.1,
                                         Color.WHITE);

            // button.resize(correspondingDoor.getWidth(), correspondingDoor.getHeight());
            doors.add(new SimpleDoor(button, owningLevel, direction, hitbox, this));
        }
    }

    @Override
    protected void initEntities() {
        List<Rectangle> spawningRegions =
                fromTiledMap.getObjectGroups().get("Enemies").getObjects().stream()
                            .map(mapObject -> new Rectangle(
                                    mapObject.getX(),
                                    mapObject.getY(),
                                    mapObject.getWidth(),
                                    mapObject.getHeight()))
                            .collect(Collectors.toList());

        for (int i = 0; i <= Math.random() * MAX_MONSTERS; i++) {
            //Text enemyNode = new Text("OooOoH spoOkY\nEneMy!");
            int randEnemy = (int) (Math.random() * (POSSIBLE_ENEMIES)) + 1;
            Enemy current;
            // TODO - make the percentages different
            switch (randEnemy) {
            case 2:
                current = new ShieldEnemy(this);
                break;
            case 3:
                current = new BigDamageEnemy(this);
                break;
            case 1:
            default:
                current = new MeleeEnemy(this);
                break;
            }
            Vector spawnPosition = getRandomSpawnPosition(spawningRegions);
            current.getDisplayNode().setTranslateX(spawnPosition.get(0));
            current.getDisplayNode().setTranslateY(spawnPosition.get(1));

            enemies.add(current);
        }
        enemies.addListener((ListChangeListener<? super Enemy>) change -> {
            if (enemies.isEmpty()) {
                hasVisited = true;
            }
            updateDoorLocks();
        });
    }

    @Override
    /**
     * Sets up a key to kill all the enemies in the rooms with the key press of "K"
     */
    public void initKillButton() {
        EventHandler<KeyEvent> keyPressed = new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent event) {
                try {
                    if (event.getCharacter().equals("k") && owningLevel.getCurrentRoom()
                                                                       .equals(SimpleRoom.this)) {
                        enemies.clear();
                        MainApp.getPrimaryStage().getScene().removeEventFilter(KeyEvent.KEY_TYPED,
                                                                               this);
                    }
                } catch (NullPointerException ignored) {
                }
            }
        };

        MainApp.getPrimaryStage().getScene().addEventFilter(KeyEvent.KEY_TYPED, keyPressed);
    }

    protected Vector getRandomSpawnPosition(List<Rectangle> spawningRegions) {
        Rectangle chosenRegion =
                spawningRegions.get((int) (Math.random() * spawningRegions.size()));

        double x = Math.random() * chosenRegion.getWidth() + chosenRegion.getX();
        double y = Math.random() * chosenRegion.getHeight() + chosenRegion.getY();

        return new Vector(x, y);
    }

}
