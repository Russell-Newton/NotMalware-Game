package whatexe.dungeoncrawler.layout.rooms;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.image.Image;
import javafx.scene.paint.Color;
import javafx.scene.shape.Path;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.Shape;
import javafx.util.Duration;
import whatexe.dungeoncrawler.entities.Entity;
import whatexe.dungeoncrawler.entities.player.Player;
import whatexe.dungeoncrawler.entities.doors.Door;
import whatexe.dungeoncrawler.entities.enemies.Enemy;
import whatexe.dungeoncrawler.entities.friends.Friend;
import whatexe.dungeoncrawler.layout.Direction;
import whatexe.dungeoncrawler.layout.Level;
import whatexe.tileengine.MapObject;
import whatexe.tileengine.PolygonObject;
import whatexe.tileengine.RectangleObject;
import whatexe.tileengine.TiledMap;

import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Vector;

public abstract class Room {
    private final Timeline tickTimer;
    protected Image backgroundImage;
    protected Level owningLevel;
    protected TiledMap fromTiledMap;
    protected ObservableList<Door> doors;
    protected ObservableList<Enemy> enemies;
    protected ObservableList<Entity> miscEntities;
    protected ObservableList<Friend> friends;
    protected ObservableList<Entity> graveyard;
    protected SimpleObjectProperty<Player> player;
    protected Shape blockedSpace;
    protected boolean hasVisited;

    public Room(TiledMap fromTiledMap, Level owningLevel, Direction... exitDirections) {
        if (fromTiledMap == null) {
            this.backgroundImage = null;
        } else {
            this.backgroundImage = SwingFXUtils.toFXImage(fromTiledMap.getMapImage(), null);
        }
        this.owningLevel = owningLevel;
        this.fromTiledMap = fromTiledMap;

        this.doors = FXCollections.observableArrayList();
        this.enemies = FXCollections.observableArrayList();
        this.miscEntities = FXCollections.observableArrayList();
        this.graveyard = FXCollections.observableArrayList();
        this.friends = FXCollections.observableArrayList();
        this.player = new SimpleObjectProperty<>(null);
        this.hasVisited = false;
        blockedSpace = new Path();

        if (fromTiledMap != null) {
            initDoors(exitDirections);
            initEntities();
            initBlockedSpace();
        }

        tickTimer = new Timeline(
                new KeyFrame(Duration.millis(5), "RoomTick", event -> tickEntities()));
        tickTimer.setCycleCount(Animation.INDEFINITE);

        // Add the special move recharge listener
        this.enemies.addListener(new ListChangeListener<Enemy>() {
            @Override
            public void onChanged(Change<? extends Enemy> change) {
                if (enemies.size() == 0) {
                    if (getPlayer() != null) {
                        getPlayer().recharge();
                    }
                    handleOnRoomClear();
                }
            }
        });
    }

    protected abstract void initDoors(Direction[] directionsToGenerate);


    /**
     * Populate the {@link Room#miscEntities} list.
     */
    protected abstract void initEntities();

    protected void initBlockedSpace() {
        if (!fromTiledMap.getObjectGroups().containsKey("OutOfBounds")) {
            blockedSpace.setFill(Color.RED);
            blockedSpace.applyCss();
            return;
        }

        for (MapObject mapObject : fromTiledMap.getObjectGroups().get("OutOfBounds").getObjects()) {
            if (mapObject instanceof RectangleObject) {
                Rectangle newRegion = new Rectangle(mapObject.getWidth(), mapObject.getHeight());
                newRegion.setTranslateX(mapObject.getX());
                newRegion.setTranslateY(mapObject.getY());
                newRegion.setRotate(((RectangleObject) mapObject).getRotation());

                newRegion.applyCss();
                blockedSpace = Shape.union(blockedSpace, newRegion);
            }
            if (mapObject instanceof PolygonObject) {
                Vector<Double>[] points = ((PolygonObject) mapObject).getPoints();
                Polygon newRegion = new Polygon();
                for (Vector<Double> point : points) {
                    newRegion.getPoints().addAll(point);
                }
                newRegion.setTranslateX(mapObject.getX());
                newRegion.setTranslateY(mapObject.getY());

                newRegion.applyCss();
                blockedSpace = Shape.union(blockedSpace, newRegion);
            }
        }

        blockedSpace.setFill(Color.RED);
        blockedSpace.applyCss();
    }

    public abstract void initKillButton();

    protected abstract void handleOnRoomClear();

    /**
     * Currently ticks entities and handles overlapping with player only.
     */
    private void tickEntities() {
        if (getPlayer() == null) {
            return;
        }

        if (getPlayer().canTick()) {
            getPlayer().tick();
        }

        for (Door door : doors) {
            if (door.canTick()) {
                door.tick();

                handleOverlappable(door);
            }
        }

        for (Friend friend : friends) {
            if (friend.canTick()) {
                friend.tick();

                handleOverlappable(friend);
            }
        }

        for (Enemy enemy : enemies) {
            if (enemy.canTick()) {
                enemy.tick();

                handleOverlappable(enemy);
            }
        }

        for (Entity entity : miscEntities) {
            if (entity.canTick()) {
                entity.tick();

                handleOverlappable(entity);
            }
        }

        clearGraveyard();
    }

    private void handleOverlappable(Entity entity) {
        List<? extends Entity> targetList = entity.getBehaviorSet().getOverlapBehavior()
                                                  .getPossibleOverlapTargets();
        if (targetList.size() == 0) {
            return;
        }
        targetList.forEach(target -> {
            if (entity.isNear(target) && entity.checkOverlap(target)) {
                entity.getBehaviorSet().handleEntityOverlap(target);
            }
        });
    }

    public Player getPlayer() {
        return player.get();
    }

    public void setPlayer(Player player) {
        this.player.set(player);
        if (player != null) {
            player.setCurrentRoom(this);
        }
    }

    public void updateDoorLocks() {
        for (Door door : doors) {
            if (this.hasVisited) {
                door.unlock();
            }
            if (door.getDirection() == null) {
                door.updateDoorLock();
                continue;
            }

            Room neighbor = owningLevel.getNeighborRoom(door.getDirection());
            if (neighbor != null && neighbor.hasVisited) {
                door.unlock();
            }
            door.updateDoorLock();
        }

    }

    public ObservableList<Entity> getMiscEntities() {
        return miscEntities;
    }

    public ObservableList<Door> getDoors() {
        return doors;
    }

    public ObservableList<Enemy> getEnemies() {
        return enemies;
    }

    public ObservableList<Friend> getFriends() {
        return friends;
    }

    public SimpleObjectProperty<Player> playerProperty() {
        return player;
    }

    public Image getBackgroundImage() {
        return backgroundImage;
    }

    public void startTicking() {
        tickTimer.play();
    }

    public void stopTicking() {
        tickTimer.stop();
    }

    public Shape getBlockedSpace() {
        return blockedSpace;
    }

    public void removeEntity(Entity toRemove) {
        if (toRemove == getPlayer()) {
            setPlayer(null);
            return;
        }

        if (toRemove instanceof Enemy && enemies.contains(toRemove)) {
            graveyard.add(toRemove);
        } else if (miscEntities.contains(toRemove)) {
            graveyard.add(toRemove);
        } else if (friends.contains(toRemove)) {
            graveyard.add(toRemove);
        }
    }

    public void addEntity(Entity toAdd) {
        if (toAdd instanceof Player) {
            setPlayer((Player) toAdd);
        } else if (toAdd instanceof Friend) {
            friends.add((Friend) toAdd);
        } else if (toAdd instanceof Enemy) {
            enemies.add((Enemy) toAdd);
        } else if (toAdd instanceof Door) {
            doors.add((Door) toAdd);
        } else {
            miscEntities.add(toAdd);
        }
    }

    public void addEntities(Collection<? extends Entity> toAdd) {
        for (Entity entity : toAdd) {
            addEntity(entity);
        }
    }

    private void clearGraveyard() {
        for (Entity entity : graveyard) {
            if (entity instanceof Enemy) {
                enemies.remove(entity);
            }
            if (entity instanceof Friend) {
                friends.remove(entity);
            } else {
                miscEntities.remove(entity);
            }
        }
        graveyard.clear();
    }

    public boolean hasVisited() {
        return hasVisited;
    }

    static class MapObjectComparator implements Comparator<MapObject> {

        @Override
        public int compare(MapObject o1, MapObject o2) {
            if (o1.equals(o2)) {
                return 0;
            }
            if (o1.getY() < o2.getY()) {
                return -1;
            } else if (o1.getY() == o2.getY()) {
                if (o1.getX() < o2.getX()) {
                    return -1;
                } else {
                    return 1;
                }
            } else {
                return 1;
            }
        }
    }
}
