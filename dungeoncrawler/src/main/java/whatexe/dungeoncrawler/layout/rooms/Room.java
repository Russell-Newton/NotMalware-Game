package whatexe.dungeoncrawler.layout.rooms;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.image.Image;
import javafx.scene.paint.Color;
import javafx.scene.shape.Path;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.Shape;
import javafx.util.Duration;
import whatexe.dungeoncrawler.entities.Entity;
import whatexe.dungeoncrawler.entities.player.Player;
import whatexe.dungeoncrawler.entities.behavior.EnemyOverlappable;
import whatexe.dungeoncrawler.entities.behavior.FriendOverlappable;
import whatexe.dungeoncrawler.entities.behavior.Overlappable;
import whatexe.dungeoncrawler.entities.doors.Door;
import whatexe.dungeoncrawler.entities.enemies.Enemy;
import whatexe.dungeoncrawler.entities.friends.Friend;
import whatexe.dungeoncrawler.layout.Direction;
import whatexe.dungeoncrawler.layout.Level;
import whatexe.tileengine.MapObject;
import whatexe.tileengine.PolygonObject;
import whatexe.tileengine.RectangleObject;
import whatexe.tileengine.TiledMap;

import java.util.Comparator;
import java.util.List;
import java.util.Vector;

public abstract class Room {
    private final Timeline tickTimer;
    protected Image backgroundImage;
    protected Level owningLevel;
    protected TiledMap fromTiledMap;
    protected ObservableList<Door> doors;
    protected ObservableList<Enemy> enemies;
    protected ObservableList<Entity> miscEntities;
    protected ObservableList<Friend> friends;
    protected ObservableList<Entity> graveyard;
    protected SimpleObjectProperty<Player> player;
    protected Shape blockedSpace;
    protected boolean hasVisited;

    public Room(TiledMap fromTiledMap, Level owningLevel, Direction... exitDirections) {
        if (fromTiledMap == null) {
            this.backgroundImage = null;
        } else {
            this.backgroundImage = SwingFXUtils.toFXImage(fromTiledMap.getMapImage(), null);
        }
        this.owningLevel = owningLevel;
        this.fromTiledMap = fromTiledMap;

        this.doors = FXCollections.observableArrayList();
        this.enemies = FXCollections.observableArrayList();
        this.miscEntities = FXCollections.observableArrayList();
        this.graveyard = FXCollections.observableArrayList();
        this.friends = FXCollections.observableArrayList();
        this.player = new SimpleObjectProperty<>(null);
        this.hasVisited = false;
        blockedSpace = new Path();

        if (fromTiledMap != null) {
            initDoors(exitDirections);
            initEntities();
            initBlockedSpace();
        }

        tickTimer = new Timeline(
                new KeyFrame(Duration.millis(5), "RoomTick", event -> tickEntities()));
        tickTimer.setCycleCount(Animation.INDEFINITE);

        // Add the special move recharge listener
        this.enemies.addListener(new ListChangeListener<Enemy>() {
            @Override
            public void onChanged(Change<? extends Enemy> change) {
                if (getPlayer() != null && enemies.size() == 0) {
                    getPlayer().recharge();
                }
            }
        });
    }

    protected abstract void initDoors(Direction[] directionsToGenerate);


    /**
     * Populate the {@link Room#miscEntities} list.
     */
    protected abstract void initEntities();

    protected void initBlockedSpace() {
        if (!fromTiledMap.getObjectGroups().containsKey("OutOfBounds")) {
            blockedSpace.setFill(Color.RED);
            blockedSpace.applyCss();
            return;
        }

        for (MapObject mapObject : fromTiledMap.getObjectGroups().get("OutOfBounds").getObjects()) {
            if (mapObject instanceof RectangleObject) {
                Rectangle newRegion = new Rectangle(mapObject.getWidth(), mapObject.getHeight());
                newRegion.setTranslateX(mapObject.getX());
                newRegion.setTranslateY(mapObject.getY());
                newRegion.setRotate(((RectangleObject) mapObject).getRotation());

                newRegion.applyCss();
                blockedSpace = Shape.union(blockedSpace, newRegion);
            }
            if (mapObject instanceof PolygonObject) {
                Vector<Double>[] points = ((PolygonObject) mapObject).getPoints();
                Polygon newRegion = new Polygon();
                for (Vector<Double> point : points) {
                    newRegion.getPoints().addAll(point);
                }
                newRegion.setTranslateX(mapObject.getX());
                newRegion.setTranslateY(mapObject.getY());

                newRegion.applyCss();
                blockedSpace = Shape.union(blockedSpace, newRegion);
            }
        }

        blockedSpace.setFill(Color.RED);
        blockedSpace.applyCss();
    }

    public abstract void initKillButton();

    /**
     * Currently ticks entities and handles overlapping with player only.
     */
    private void tickEntities() {
        if (getPlayer() != null && getPlayer().canTick()) {
            getPlayer().tick();
        }

        for (Door door : doors) {
            if (door.canTick()) {
                door.tick();

                if (getPlayer() != null) {
                    handleOverlappable(door, List.of(getPlayer()), FriendOverlappable.class);
                }
            }
        }

        for (Friend friend : friends) {
            if (friend.canTick()) {
                friend.tick();

                handleOverlappable(friend, enemies, EnemyOverlappable.class);
            }
        }

        for (Enemy enemy : enemies) {
            if (enemy.canTick()) {
                enemy.tick();

                if (getPlayer() != null) {
                    handleOverlappable(enemy, List.of(getPlayer()), FriendOverlappable.class);
                }
                handleOverlappable(enemy, friends, FriendOverlappable.class);
            }
        }

        for (Entity entity : miscEntities) {
            if (entity.canTick()) {
                entity.tick();

                if (getPlayer() != null) {
                    handleOverlappable(entity, List.of(getPlayer()), FriendOverlappable.class);
                }
                handleOverlappable(entity, friends, FriendOverlappable.class);
                handleOverlappable(entity, enemies, EnemyOverlappable.class);
            }
        }

        clearGraveyard();
    }

    private <T extends Overlappable<V>,
            V extends Entity> void handleOverlappable(Entity entity,
                                                      List<V> targetList,
                                                      Class<? extends T> overlappableClass) {
        if (targetList.size() == 0) {
            return;
        }
        if (overlappableClass.isInstance(entity)) {
            T casted = overlappableClass.cast(entity);
            targetList.forEach(target -> {
                if (entity.isNear(target) && entity.checkOverlap(target)) {
                    casted.handleOverlap(target);
                }
            });
        }
    }

    public Player getPlayer() {
        return player.get();
    }

    public void setPlayer(Player player) {
        this.player.set(player);
        if (player != null) {
            player.setCurrentRoom(this);
        }
    }

    public void updateDoorLocks() {
        for (Door door : doors) {
            if (this.hasVisited) {
                door.unlock();
            }
            if (door.getDirection() == null) {
                door.updateDoorLock();
                continue;
            }

            Room neighbor = owningLevel.getNeighborRoom(door.getDirection());
            if (neighbor != null && neighbor.hasVisited) {
                door.unlock();
            }
            door.updateDoorLock();
        }

    }

    public ObservableList<Entity> getMiscEntities() {
        return miscEntities;
    }

    public ObservableList<Door> getDoors() {
        return doors;
    }

    public ObservableList<Enemy> getEnemies() {
        return enemies;
    }

    public ObservableList<Friend> getFriends() {
        return friends;
    }

    public SimpleObjectProperty<Player> playerProperty() {
        return player;
    }

    public Image getBackgroundImage() {
        return backgroundImage;
    }

    public void startTicking() {
        tickTimer.play();
    }

    public void stopTicking() {
        tickTimer.stop();
    }

    public Shape getBlockedSpace() {
        return blockedSpace;
    }

    public void removeEntity(Entity toRemove) {
        if (toRemove == getPlayer()) {
            setPlayer(null);
            return;
        }

        if (toRemove instanceof Enemy && enemies.contains(toRemove)) {
            graveyard.add(toRemove);
        } else if (miscEntities.contains(toRemove)) {
            graveyard.add(toRemove);
        } else if (friends.contains(toRemove)) {
            graveyard.add(toRemove);
        }
    }

    private void clearGraveyard() {
        for (Entity entity : graveyard) {
            if (entity instanceof Enemy) {
                enemies.remove(entity);
            }
            if (entity instanceof Friend) {
                friends.remove(entity);
            } else {
                miscEntities.remove(entity);
            }
        }
        graveyard.clear();
    }

    public boolean hasVisited() {
        return hasVisited;
    }

    static class MapObjectComparator implements Comparator<MapObject> {

        @Override
        public int compare(MapObject o1, MapObject o2) {
            if (o1.equals(o2)) {
                return 0;
            }
            if (o1.getY() < o2.getY()) {
                return -1;
            } else if (o1.getY() == o2.getY()) {
                if (o1.getX() < o2.getX()) {
                    return -1;
                } else {
                    return 1;
                }
            } else {
                return 1;
            }
        }
    }
}
