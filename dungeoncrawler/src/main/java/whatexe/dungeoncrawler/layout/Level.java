package whatexe.dungeoncrawler.layout;

import whatexe.dungeoncrawler.Difficulty;
import whatexe.dungeoncrawler.layout.generation.RoomPosition;
import whatexe.dungeoncrawler.layout.generation.RoomPositionProperty;
import whatexe.dungeoncrawler.layout.rooms.Room;
import whatexe.dungeoncrawler.layout.rooms.SimpleRoom;
import whatexe.dungeoncrawler.layout.rooms.StartingRoom;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

public class Level {

    private final RoomPositionProperty currentRoomPosition;
    private final Map<RoomPosition, Room> maze;
    private final Difficulty difficulty;
    private final int depth;
    private int minX;
    private int maxX;
    private int minY;
    private int maxY;

    public Level(Difficulty difficulty) {
        this(difficulty, new RoomPosition(0, 0));
    }

    public Level(Difficulty difficulty, int depth) {
        this(difficulty, new RoomPosition(0, 0), depth);
    }

    public Level(Difficulty difficulty, RoomPosition startingRoomPosition) {
        this(difficulty, startingRoomPosition, 0);
    }

    public Level(Difficulty difficulty, RoomPosition startingRoomPosition, int depth) {
        currentRoomPosition = new RoomPositionProperty(startingRoomPosition);
        maze = new HashMap<>();
        this.difficulty = difficulty;
        this.depth = depth;
        minX = 1;
        maxX = -1;
        minY = 1;
        maxY = -1;
    }

    public Room getCurrentRoom() {
        return maze.get(currentRoomPosition.get());
    }

    public Room moveUp() {
        currentRoomPosition.set(currentRoomPosition.get().getAbove());
        return getCurrentRoom();
    }

    public Room moveDown() {
        currentRoomPosition.set(currentRoomPosition.get().getBelow());
        return getCurrentRoom();
    }

    public Room moveLeft() {
        currentRoomPosition.set(currentRoomPosition.get().getLeft());
        return getCurrentRoom();
    }

    public Room moveRight() {
        currentRoomPosition.set(currentRoomPosition.get().getRight());
        return getCurrentRoom();
    }

    public Room move(Direction direction) {
        currentRoomPosition.set(currentRoomPosition.get().getNeighbor(direction));
        return getCurrentRoom();
    }

    public Map<RoomPosition, Room> getMaze() {
        return maze;
    }

    public RoomPositionProperty currentRoomPositionProperty() {
        return currentRoomPosition;
    }

    private void initBounds() {
        for (RoomPosition position : maze.keySet()) {
            minX = Math.min(minX, position.getX());
            minY = Math.min(minY, position.getY());
            maxX = Math.max(maxX, position.getX());
            maxY = Math.max(maxY, position.getY());
        }
    }

    public int getHeight() {
        if (minX == 1) {
            initBounds();
        }
        return maxY - minY + 1;
    }

    public int getWidth() {
        if (minX == 1) {
            initBounds();
        }
        return maxX - minX + 1;
    }

    public String mazeToString() {
        getHeight();
        String[][] mazeRep = new String[maxY - minY + 1][maxX - minX + 1];
        for (Map.Entry<RoomPosition, Room> entry : maze.entrySet()) {
            RoomPosition position = entry.getKey();
            Room room = entry.getValue();
            String toAdd;
            if (position.equals(currentRoomPosition.get())) {
                toAdd = "P";
            } else if (StartingRoom.class.equals(room.getClass())) {
                toAdd = "O";
            } else if (SimpleRoom.class.equals(room.getClass())) {
                toAdd = "*";
            } else {
                toAdd = room.getClass().getSimpleName().charAt(0) + "";
            }
            mazeRep[position.getY() - minY][position.getX() - minX] = toAdd;
        }

        StringBuilder builder = new StringBuilder();
        for (String[] row : mazeRep) {
            for (String room : row) {
                builder.append(Objects.requireNonNullElse(room, " "));
            }
            builder.append("\n");
        }

        return builder.toString();
    }

    public Room getNeighborRoom(Direction direction) {
        return getMaze().get(currentRoomPosition.get().getNeighbor(direction));
    }

    public RoomPosition getRoomPosition() {
        return currentRoomPosition.get();
    }

    public int getDepth() {
        return depth;
    }

    public int getMaxDanger() {
        return difficulty.getMaxDanger(depth);
    }

    public Difficulty getDifficulty() {
        return difficulty;
    }
}
