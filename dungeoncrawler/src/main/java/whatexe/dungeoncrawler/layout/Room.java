package whatexe.dungeoncrawler.layout;

import javafx.animation.AnimationTimer;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.image.Image;
import whatexe.dungeoncrawler.entities.Door;
import whatexe.dungeoncrawler.entities.Enemy;
import whatexe.dungeoncrawler.entities.Entity;
import whatexe.dungeoncrawler.entities.Player;
import whatexe.tileengine.TiledMap;

public abstract class Room {
    protected Image backgroundImage;
    protected Level owningLevel;
    protected TiledMap fromTiledMap;
    protected ObservableList<Door> doors;
    protected ObservableList<Enemy> enemies;
    protected ObservableList<Entity> miscEntities;
    protected SimpleObjectProperty<Player> player;
    private AnimationTimer tickTimer;

    public Room(TiledMap fromTiledMap, Level owningLevel, Direction... directionsToGenerate) {
        if (fromTiledMap == null) {
            this.backgroundImage = null;
        } else {
            this.backgroundImage = SwingFXUtils.toFXImage(fromTiledMap.getMapImage(), null);
        }
        this.owningLevel = owningLevel;
        this.fromTiledMap = fromTiledMap;

        this.doors = FXCollections.observableArrayList();
        this.enemies = FXCollections.observableArrayList();
        this.miscEntities = FXCollections.observableArrayList();
        this.player = new SimpleObjectProperty<>(null);

        if (fromTiledMap != null) {
            initDoors(directionsToGenerate);
            initEntities();
        }

        tickTimer = new AnimationTimer() {
            @Override
            public void handle(long now) {
                tickEntities(now);
            }
        };
    }

    protected abstract void initDoors(Direction[] directionsToGenerate);

    /**
     * Populate the {@link Room#miscEntities} list.
     */
    protected abstract void initEntities();

    public ObservableList<Entity> getMiscEntities() {
        return miscEntities;
    }

    public ObservableList<Door> getDoors() {
        return doors;
    }

    public ObservableList<Enemy> getEnemies() {
        return enemies;
    }

    public Player getPlayer() {
        return player.get();
    }

    public void setPlayer(Player player) {
        this.player.set(player);
        if (player != null) {
            player.setCurrentRoom(this);
        }
    }

    public SimpleObjectProperty<Player> playerProperty() {
        return player;
    }

    public Image getBackgroundImage() {
        return backgroundImage;
    }

    public void startTicking() {
        tickTimer.start();
    }

    public void stopTicking() {
        tickTimer.stop();
    }

    private void tickEntities(long now) {
        if (getPlayer().canTick()) {
            getPlayer().tick(now);
        }

        for (Door door : doors) {
            if (door.canTick()) {
                door.tick(now);
            }
        }

        for (Enemy enemy : enemies) {
            if (enemy.canTick()) {
                enemy.tick(now);
            }
        }

        for (Entity entity : miscEntities) {
            if (entity.canTick()) {
                entity.tick(now);
            }
        }
    }
}
