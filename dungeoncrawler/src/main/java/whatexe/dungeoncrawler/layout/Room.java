package whatexe.dungeoncrawler.layout;

import javafx.animation.Animation;
import javafx.animation.AnimationTimer;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.image.Image;
import javafx.scene.paint.Color;
import javafx.scene.shape.Path;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.Shape;
import javafx.util.Duration;
import whatexe.dungeoncrawler.entities.*;
import whatexe.tileengine.MapObject;
import whatexe.tileengine.PolygonObject;
import whatexe.tileengine.RectangleObject;
import whatexe.tileengine.TiledMap;

import java.util.Comparator;
import java.util.Vector;

public abstract class Room {
    protected Image backgroundImage;
    protected Level owningLevel;
    protected TiledMap fromTiledMap;
    protected ObservableList<Door> doors;
    protected ObservableList<Enemy> enemies;
    protected ObservableList<Entity> miscEntities;
    protected SimpleObjectProperty<Player> player;
    protected Shape blockedSpace;
    private final Timeline tickTimer;

    public Room(TiledMap fromTiledMap, Level owningLevel, Direction... exitDirections) {
        if (fromTiledMap == null) {
            this.backgroundImage = null;
        } else {
            this.backgroundImage = SwingFXUtils.toFXImage(fromTiledMap.getMapImage(), null);
        }
        this.owningLevel = owningLevel;
        this.fromTiledMap = fromTiledMap;

        this.doors = FXCollections.observableArrayList();
        this.enemies = FXCollections.observableArrayList();
        this.miscEntities = FXCollections.observableArrayList();
        this.player = new SimpleObjectProperty<>(null);
        blockedSpace = new Path();

        if (fromTiledMap != null) {
            initDoors(exitDirections);
            initEntities();
            initBlockedSpace();
        }

        tickTimer = new Timeline(new KeyFrame(Duration.millis(5), "RoomTick", event -> {
            tickEntities();
        }));
        tickTimer.setCycleCount(Animation.INDEFINITE);
    }

    protected abstract void initDoors(Direction[] directionsToGenerate);

    /**
     * Populate the {@link Room#miscEntities} list.
     */
    protected abstract void initEntities();

    protected void initBlockedSpace() {
        if (!fromTiledMap.getObjectGroups().containsKey("OutOfBounds")) {
            blockedSpace.setFill(Color.RED);
            blockedSpace.applyCss();
            return;
        }

        for (MapObject mapObject : fromTiledMap.getObjectGroups().get("OutOfBounds").getObjects()) {
            if (mapObject instanceof RectangleObject) {
                Rectangle newRegion = new Rectangle(mapObject.getWidth(), mapObject.getHeight());
                newRegion.setTranslateX(mapObject.getX());
                newRegion.setTranslateY(mapObject.getY());
                newRegion.setRotate(((RectangleObject) mapObject).getRotation());

                newRegion.applyCss();
                blockedSpace = Shape.union(blockedSpace, newRegion);
            }
            if (mapObject instanceof PolygonObject) {
                Vector<Double>[] points = ((PolygonObject) mapObject).getPoints();
                Polygon newRegion = new Polygon();
                for (Vector<Double> point : points) {
                    newRegion.getPoints().addAll(point);
                }
                newRegion.setTranslateX(mapObject.getX());
                newRegion.setTranslateY(mapObject.getY());

                newRegion.applyCss();
                blockedSpace = Shape.union(blockedSpace, newRegion);
            }
        }

        blockedSpace.setFill(Color.RED);
        blockedSpace.applyCss();
    }

    /**
     * Currently ticks entities and handles overlapping with player only.
     */
    private void tickEntities() {
        if (getPlayer().canTick()) {
            getPlayer().tick();
        }

        for (Door door : doors) {
            if (door.canTick()) {
                door.tick();

                if (door.isNear(getPlayer()) && door.checkOverlap(getPlayer())) {
                    door.handleOverlap(getPlayer());
                }
            }
        }

        for (Enemy enemy : enemies) {
            if (enemy.canTick()) {
                enemy.tick();

                if (enemy.isNear(getPlayer()) && enemy.checkOverlap(getPlayer())) {
                    enemy.handleOverlap(getPlayer());
                }
            }
        }

        for (Entity entity : miscEntities) {
            if (entity.canTick()) {
                entity.tick();

                if (entity instanceof PlayerOverlappable) {
                    PlayerOverlappable casted = (PlayerOverlappable) entity;
                    if (entity.isNear(getPlayer()) && entity.checkOverlap(getPlayer())) {
                        casted.handleOverlap(getPlayer());
                    }
                }
                if (entity instanceof EnemyOverlappable && enemies.size() > 0) {
                    EnemyOverlappable casted = (EnemyOverlappable) entity;
                    enemies.forEach(enemy -> {
                        if (entity.isNear(enemy) && entity.checkOverlap(enemy)) {
                            casted.handleOverlap(enemy);
                        }
                    });
                }
            }
        }
    }

    public Player getPlayer() {
        return player.get();
    }

    public void setPlayer(Player player) {
        this.player.set(player);
        if (player != null) {
            player.setCurrentRoom(this);
        }
    }

    public ObservableList<Entity> getMiscEntities() {
        return miscEntities;
    }

    public ObservableList<Door> getDoors() {
        return doors;
    }

    public ObservableList<Enemy> getEnemies() {
        return enemies;
    }

    public SimpleObjectProperty<Player> playerProperty() {
        return player;
    }

    public Image getBackgroundImage() {
        return backgroundImage;
    }

    public void startTicking() {
        tickTimer.play();
    }

    public void stopTicking() {
        tickTimer.stop();
    }

    public Shape getBlockedSpace() {
        return blockedSpace;
    }


    static class MapObjectComparator implements Comparator<MapObject> {

        @Override
        public int compare(MapObject o1, MapObject o2) {
            if (o1.getY() < o2.getY()) {
                return -1;
            } else if (o1.getY() == o2.getY()) {
                if (o1.getX() < o2.getX()) {
                    return -1;
                } else {
                    return 1;
                }
            } else {
                return 1;
            }
        }
    }
}
