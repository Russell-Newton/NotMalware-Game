package whatexe.dungeoncrawler.layout;


import whatexe.tileengine.TiledMap;

import java.io.IOException;
import java.util.*;


public class SimpleLevelGenerator implements LevelGenerator {

    // Constants for calculating when to pivot the crawling direction
    private static final double PIVOT_CHANCE_SCALE = 1;
    private static final double PIVOT_CHANCE_SHIFT_UP = 0.75;
    private static final double PIVOT_CHANCE_SHIFT_RIGHT = 4.5;

    // Constants for calculating when to create a dead end
    private static final double DEAD_END_CHANCE_BASE = 1.6;
    private static final double DEAD_END_CHANCE_SCALE = 3;

    // Constants for calculating when to create a boss room
    private static final int MIN_BOSS_DEPTH = 6;
    private static final double BOSS_ROOM_SCALE = 8;

    // Constants for determining when to add rooms
    private static final int MAX_ROOMS = 15;
    private static final double ADD_ROOM_CHANCE = 0.65;
    private static final double CLUMP_CHANCE = 0.25;

    // Default TiledMap for creating new Rooms
    private static final TiledMap DEFAULT_TILED_MAP;
    static {
        TiledMap tempMap;
        try {
            tempMap
                    = new TiledMap(SimpleLevelGenerator.class.getResource("Calibration.tmx"));
        } catch (IOException e) {
            tempMap = null;
            e.printStackTrace();
        }
        DEFAULT_TILED_MAP = tempMap;
    }

    private final Random randomizer;
    private final RoomPosition startingPosition = new RoomPosition(0, 0);

    // Generated by generate()
    private Level level;
    private RoomPosition bossRoomPosition;
    private Set<RoomPosition> rooms;
    private Set<RoomPosition> deadEnds;


    public SimpleLevelGenerator() {
        randomizer = new Random();
    }

    public SimpleLevelGenerator(long seed) {
        randomizer = new Random(seed);
    }

    /**
     * Used to determine if the current room should be a dead end.
     * Based on an exponential function, set up with constants
     * {@link SimpleLevelGenerator#MAX_ROOMS},
     * {@link SimpleLevelGenerator#DEAD_END_CHANCE_SCALE}, and
     * {@link SimpleLevelGenerator#DEAD_END_CHANCE_BASE}.
     *
     * @param randomizer randomizer, so a seed can be used.
     * @param depth      current room depth.
     * @return if the current room should be a dead end.
     */
    private static boolean shouldBeDeadEnd(Random randomizer, int depth) {
        double y = (DEAD_END_CHANCE_SCALE / MAX_ROOMS) * Math.pow(DEAD_END_CHANCE_BASE, depth);
        return randomizer.nextDouble() < y;
    }

    /**
     * Used to determine if the current room should be the boss room.
     * Based on a linear function, set up with constants
     * {@link SimpleLevelGenerator#MAX_ROOMS},
     * {@link SimpleLevelGenerator#MIN_BOSS_DEPTH}, and
     * {@link SimpleLevelGenerator#BOSS_ROOM_SCALE}.
     *
     * @param randomizer randomizer, so a seed can be used.
     * @param depth      current room depth.
     * @return if the current room should be a boss room.
     */
    private static boolean shouldBeBossRoom(Random randomizer, int depth) {
        double y = (BOSS_ROOM_SCALE / MAX_ROOMS) * (depth - (MIN_BOSS_DEPTH - 1));
        return randomizer.nextDouble() < y;
    }

    /**
     * Used to determine if the primary crawl direction should change.
     * Based on a negative quadratic function, set up with constants
     * {@link SimpleLevelGenerator#MAX_ROOMS},
     * {@link SimpleLevelGenerator#PIVOT_CHANCE_SCALE},
     * {@link SimpleLevelGenerator#PIVOT_CHANCE_SHIFT_UP}, and
     * {@link SimpleLevelGenerator#PIVOT_CHANCE_SHIFT_RIGHT}.
     *
     * @param randomizer randomizer, so a seed can be used.
     * @param depth      current room depth.
     * @return if the primary crawl direction should pivot.
     */
    private static boolean shouldPivot(Random randomizer, int depth) {
        double y =
                -(1.0 / (MAX_ROOMS * PIVOT_CHANCE_SCALE))
                        * Math.pow((depth - PIVOT_CHANCE_SHIFT_RIGHT), 2)
                        + PIVOT_CHANCE_SHIFT_UP;
        return randomizer.nextDouble() < y;
    }

    private static <T> Set<T> setIntersection(Set<T> a, Set<T> b) {
        Set<T> c = new HashSet<>();
        for (T t : a) {
            if (b.contains(t)) {
                c.add(t);
            }
        }

        return c;
    }

    @Override
    public Level generate() {
        bossRoomPosition = null;
        rooms = new HashSet<>();
        deadEnds = new HashSet<>();
        level = new Level();

        List<Direction> directionOptions = new ArrayList<>(Arrays.asList(Direction.values()));

        // Randomly choose order of crawling to start
        Direction[] startCrawlDirections = new Direction[4];
        for (int i = 0; i < startCrawlDirections.length; i++) {
            startCrawlDirections[i]
                    = directionOptions.remove(randomizer.nextInt(directionOptions.size()));
        }

        rooms.add(startingPosition);
        for (Direction direction : startCrawlDirections) {
            crawl(direction, direction, startingPosition.getNeighbor(direction));
        }

        initRooms();

        return level;
    }

    private void crawl(Direction primaryDirection,
                       Direction currentDirection,
                       RoomPosition currentPosition) {
        rooms.add(currentPosition);
        if (rooms.size() >= MAX_ROOMS || deadEnds.contains(currentPosition)) {
            return;
        }

        if (shouldPivot(randomizer, currentPosition.distance(startingPosition))) {
            Direction option1 = currentDirection.getCCW();
            Direction option2 = currentDirection.getCW();

            // Avoid looping back
            if (option1 == primaryDirection.getOpposite()) {
                option1 = currentDirection;
            }
            if (option2 == primaryDirection.getOpposite()) {
                option2 = currentDirection;
            }

            // Avoid clusters
            if (neighbors(currentPosition.getNeighbor(option1),
                          Set.of(option1.getOpposite())).size() > 0) {
                option1 = currentDirection;
            }
            if (neighbors(currentPosition.getNeighbor(option2),
                          Set.of(option2.getOpposite())).size() > 0) {
                option2 = currentDirection;
            }

            // Change direction
            if (randomizer.nextBoolean()) {
                currentDirection = option1;
            } else {
                currentDirection = option2;
            }
        }

        // Primary crawl
        if (bossRoomPosition == null) {
            RoomPosition neighbor = currentPosition.getNeighbor(currentDirection);
            if (shouldBeBossRoom(randomizer, neighbor.distance(startingPosition))) {
                bossRoomPosition = neighbor;
                deadEnds.add(bossRoomPosition);
            }
            crawl(primaryDirection, currentDirection, neighbor);
        }

        for (Direction direction : setIntersection(Set.of(Direction.values()),
                                                   Set.of(currentDirection,
                                                          currentDirection.getCCW(),
                                                          currentDirection.getCW()))) {

            RoomPosition nextPosition = currentPosition.getNeighbor(direction);
            if (rooms.contains(nextPosition)) {
                continue;
            }

            Set<RoomPosition> futureNeighbors = neighbors(nextPosition,
                                                          Set.of(direction.getOpposite()));

            // Check if room should be added in the first place
            boolean addRoom = randomizer.nextDouble() < ADD_ROOM_CHANCE;
            // Check for clumps... if clump isn't acceptable, remove
            if (futureNeighbors.size() > 0 && randomizer.nextDouble() > CLUMP_CHANCE) {
                addRoom = false;
            }
            addRoom &= setIntersection(futureNeighbors, deadEnds).size() == 0;

            // Create dead end if desired
            if (addRoom && bossRoomPosition != null
                    && shouldBeDeadEnd(randomizer, nextPosition.distance(startingPosition))) {
                deadEnds.add(nextPosition);
                rooms.add(nextPosition);
            }

            addRoom &= !rooms.contains(nextPosition);

            if (addRoom) {
                crawl(primaryDirection, direction, nextPosition);
            }
        }
    }


    private Set<RoomPosition> neighbors(RoomPosition queryPosition,
                                        Set<Direction> excludeDirections) {
        Set<RoomPosition> neighbors = new HashSet<>();
        for (Direction direction : Direction.values()) {
            if (!excludeDirections.contains(direction)
                    && rooms.contains(queryPosition.getNeighbor(direction))) {
                neighbors.add(queryPosition.getNeighbor(direction));
            }
        }
        return neighbors;
    }

    private void initRooms() {
        // reset dead ends
        deadEnds = new HashSet<>();

        for (RoomPosition position : rooms) {
            Set<Direction> exits = new HashSet<>();
            for (Direction direction : Direction.values()) {
                if (rooms.contains(position.getNeighbor(direction))) {
                    exits.add(direction);
                }
            }

            if (exits.size() == 1) {
                deadEnds.add(position);
            }

            if (position.equals(bossRoomPosition)) {
                level.getMaze().put(position,
                                    new BossRoom(DEFAULT_TILED_MAP,
                                                 level,
                                                 exits.toArray(Direction[]::new)[0]
                                    ));
            } else {
                level.getMaze().put(position,
                                    new SimpleRoom(DEFAULT_TILED_MAP,
                                                   level,
                                                   exits.toArray(Direction[]::new)
                                    ));
            }
        }
    }

    public RoomPosition getStartingPosition() {
        return startingPosition;
    }

    public Level getLevel() {
        return level;
    }

    public RoomPosition getBossRoomPosition() {
        return bossRoomPosition;
    }

    public Set<RoomPosition> getRooms() {
        return rooms;
    }

    public Set<RoomPosition> getDeadEnds() {
        return deadEnds;
    }
}
