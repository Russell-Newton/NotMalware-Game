package whatexe.dungeoncrawler;

import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;

import java.io.IOException;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

/**
 * The SceneManager allows for managing a lot of FXML Scenes by using methods that can change the
 * state of Scenes. It can also be used to save and load states. Ideally, a scene should be
 * unloaded when not needed, so that it doesn't hang in memory, but it can be loaded back up when
 * needed.
 * <br><br>
 * Scenes managed by a SceneManager are saved as FXML files, with controllers that extend
 * {@link ManagedController}.
 * <br><br>
 * The SceneManager is modeled as a Singleton. Only one instance ever exists. Access its methods
 * with the provided {@link SceneManager#getInstance()} method.
 */
public class SceneManager {

    private static SceneManager instance;

    /**
     * This map contains the {@link FXMLLoader}s that represent each scene added to the
     * SceneManager.
     * FXMLLoader instances are initialized with {@link URL} locations, such as those generated by
     * <PRE>
     * getClass().getResource(filepath);
     * </PRE>
     * The scenes and {@link ManagedController}s defined by these FXMLLoaders are only loaded
     * when {@link SceneManager#loadScene(String)} is called. The loaders are subsequently
     * replaced by unloaded FXMLLoaders that haven't loaded the scenes and controllers from the
     * FXML yet when {@link SceneManager#unloadScene(String)} is called.
     */
    private final Map<String, FXMLLoader> loaderMap;

    /**
     * This map contains the {@link Scene}s that are currently loaded in the SceneManager. This
     * map is important, because FXMLLoaders can only be used to create a Scene once.
     * <br><br>
     * Calling code like the following multiple times will fail.
     * <PRE>
     * new Scene(loader.getRoot())
     * </PRE>
     * This map is a workaround to keep this error from appearing.
     */
    private final Map<String, Scene> sceneMap;

    private SceneManager() {
        loaderMap = new HashMap<>();
        sceneMap = new HashMap<>();
    }

    /**
     * @return the only instance of the SceneManager for this JVM.
     */
    public static SceneManager getInstance() {
        if (instance == null) {
            instance = new SceneManager();
        }
        return instance;
    }

    /**
     * Adds a scene to the {@link SceneManager#loaderMap}.
     *
     * @param sceneName the name of the scene, used for future referral.
     * @param location  the {@link URL} location of the FXML file. Can be generated by
     *                  <PRE>
     *                  getClass().getResource(filepath);
     *                  </PRE>
     */
    public void addScene(String sceneName, URL location) {
        if (loaderMap.containsKey(sceneName)) {
            throw new RuntimeException("Scene " + sceneName + " already added!");
        }
        FXMLLoader loader = new FXMLLoader(location);
        loaderMap.put(sceneName, loader);
    }

    /**
     * Removes an unloaded scene from the {@link SceneManager#loaderMap}. Scenes should be unloaded
     * before being removed from the loaderMap.
     *
     * @param sceneName the name of the scene, as entered in {@link SceneManager#addScene(String,
     *                  URL)}.
     */
    public void removeScene(String sceneName) {
        FXMLLoader loader = loaderMap.remove(sceneName);
        if (loader == null) {
            throw new RuntimeException("Cannot remove a scene that hasn't been added!");
        }
    }

    /**
     * Removes every scene from the SceneManager.
     */
    public void clear() {
        loaderMap.clear();
        sceneMap.clear();
    }

    /**
     * Gets a loaded scene from the {@link SceneManager#loaderMap}. Scenes have to be loaded by
     * {@link SceneManager#loadScene(String)} for this method to work.
     *
     * @param sceneName the name of the scene, as entered in {@link SceneManager#addScene(String,
     *                  URL)}.
     * @return the {@link Scene}.
     */
    public Scene getScene(String sceneName) {
        FXMLLoader loader = loaderMap.get(sceneName);
        Scene scene = sceneMap.get(sceneName);
        if (scene == null) {
            throw new RuntimeException("Cannot get an uninitialized scene!");
        }

        return scene;
    }

    /**
     * Gets the loaded {@link ManagedController} defined by the specified {@link FXMLLoader} mapped
     * from sceneName in the {@link SceneManager#loaderMap}.
     *
     * @param sceneName the name of the scene, as entered in {@link SceneManager#addScene(String,
     *                  URL)}.
     * @return the {@link ManagedController}.
     */
    public ManagedController getSceneController(String sceneName) {
        FXMLLoader loader = loaderMap.get(sceneName);
        if (loader.getRoot() == null) {
            throw new RuntimeException("Cannot get the controller of an uninitialized scene!");
        }

        return loader.getController();
    }

    /**
     * Loads a scene in the {@link SceneManager#loaderMap}. Initializes the
     * corresponding {@link ManagedController}. Scenes that are already loaded cannot be loaded
     * again.
     *
     * @param sceneName the name of the scene, as entered in
     *                  {@link SceneManager#addScene(String, URL)}.
     * @return the loaded {@link Scene}, for method chaining.
     *
     * @throws IOException if the FXML file specified by the {@link URL} passed into
     *                     {@link SceneManager#addScene(String, URL)} cannot be opened.
     * @see SceneManager#loadScene(String, Map)
     */
    public Scene loadScene(String sceneName) throws IOException {
        return loadScene(sceneName, Map.of());
    }

    /**
     * Loads a scene in the {@link SceneManager#loaderMap}. Initializes the
     * corresponding {@link ManagedController}. Scenes that are already loaded cannot be loaded
     * again.
     *
     * @param sceneName      the name of the scene, as entered in
     *                       {@link SceneManager#addScene(String, URL)}.
     * @param loadParameters optional parameters that are sent into the ManagedController's
     *                       {@link ManagedController#init(Map)} method.
     * @return the loaded {@link Scene}, for method chaining.
     *
     * @throws IOException if the FXML file specified by the {@link URL} passed into
     *                     {@link SceneManager#addScene(String, URL)} cannot be opened.
     * @see SceneManager#loadScene(String)
     */
    public Scene loadScene(String sceneName, Map<String, Object> loadParameters) throws IOException {
        FXMLLoader loader = loaderMap.get(sceneName);
        if (loader.getRoot() != null) {
            throw new RuntimeException("Cannot initialize an already initialized scene!");
        }

        // Attempt to load the root node and controller
        Parent root = loader.load();
        ManagedController controller = loader.getController();

        if (controller == null) {
            throw new RuntimeException(
                    "Scene FXML must specify a controller that extends ManagedController!");
        }

        if (!(controller instanceof ManagedController)) {
            throw new RuntimeException("Scene's controller must extend ManagedController!");
        }

        // Initialize the controller
        controller.init(loadParameters);

        Scene scene = new Scene(root);
        sceneMap.put(sceneName, scene);

        return scene;
    }

    /**
     * Unload a loaded scene. This releases it from active memory within the
     * {@link SceneManager#loaderMap}. The associated {@link Scene} and {@link ManagedController}
     * will stay active in memory and will not be garbage collected if they are referenced
     * somewhere outside of the {@link SceneManager}.
     *
     * @param sceneName the name of the scene, as entered in {@link SceneManager#addScene(String,
     *                  URL)}.
     * @return the Scene that has been unloaded from the SceneManager.
     */
    public Scene unloadScene(String sceneName) {
        FXMLLoader loader = loaderMap.get(sceneName);
        Scene scene = sceneMap.remove(sceneName);
        if (scene == null) {
            throw new RuntimeException("Cannot unload an unloaded scene!");
        }

        loaderMap.put(sceneName, new FXMLLoader(loader.getLocation()));

        return scene;
    }

    /**
     * Sets the state of a loaded scene's {@link ManagedController} using its
     * {@link ManagedController#setState(Map)} method. Behavior of this method is completely
     * determined by the ManagedController's definition.
     *  @param sceneName       the name of the scene, as entered in
     *                        {@link SceneManager#addScene(String,
     *                        URL)}.
     * @param stateParameters a map of parameters used to set the state. Passed into
     * {@link ManagedController#setState(Map)}.
     */
    public void setSceneState(String sceneName, Map<String, Object> stateParameters) {
        FXMLLoader loader = loaderMap.get(sceneName);
        if (loader.getRoot() == null) {
            throw new RuntimeException("Cannot set the state of an uninitialized scene!");
        }

        ManagedController controller = loader.getController();
        controller.setState(stateParameters);
    }

    /**
     * Resets the state of a loaded scene's {@link ManagedController} using its
     * {@link ManagedController#resetState()} method. Behavior of this method is completely
     * determined by the ManagedController's definition.
     *
     * @param sceneName the name of the scene, as entered in {@link SceneManager#addScene(String,
     *                  URL)}
     */
    public void resetSceneState(String sceneName) {
        FXMLLoader loader = loaderMap.get(sceneName);
        if (loader.getRoot() == null) {
            throw new RuntimeException("Cannot set the state of an uninitialized scene!");
        }

        ManagedController controller = loader.getController();
        controller.resetState();
    }

    /**
     * Saves the state of a loaded scene's {@link ManagedController} using its
     * {@link ManagedController#saveState(String)} method. Behavior of this method is completely
     * determined by the ManagedController's definition of
     * {@link ManagedController#setSaveDataFromState()}.
     *
     * @param sceneName the name of the scene, as entered in {@link SceneManager#addScene(String,
     *                  URL)}.
     * @param location  the location of the save file, passed into the controller's saveState
     *                  method.
     */
    public void saveSceneState(String sceneName, String location) {
        FXMLLoader loader = loaderMap.get(sceneName);
        if (loader.getRoot() == null) {
            throw new RuntimeException("Cannot save the state of an uninitialized scene!");
        }

        ManagedController controller = loader.getController();
        controller.saveState(location);
    }

    /**
     * Loads the state of a loaded scene's {@link ManagedController} using its
     * {@link ManagedController#loadState(String)} method. Behavior of this method is completely
     * determined by the ManagedController's definition of
     * {@link ManagedController#setStateFromSaveData()}.
     *
     * @param sceneName the name of the scene, as entered in {@link SceneManager#addScene(String,
     *                  URL)}.
     * @param location the location of the save file to load from, passed into the controller's
     *                 loadState method.
     */
    public void loadSceneState(String sceneName, String location) {
        FXMLLoader loader = loaderMap.get(sceneName);
        if (loader.getRoot() == null) {
            throw new RuntimeException("Cannot load the state of an uninitialized scene!");
        }

        ManagedController controller = loader.getController();
        controller.loadState(location);
    }

    public Map<String, FXMLLoader> getLoaderMap() {
        return loaderMap;
    }
}
