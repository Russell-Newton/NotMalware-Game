package whatexe.dungeoncrawler.entities.behavior.attack;

import whatexe.dungeoncrawler.entities.Player;
import whatexe.dungeoncrawler.entities.behavior.EntityBehavior;
import whatexe.dungeoncrawler.entities.motionsupport.Vector;
import whatexe.dungeoncrawler.entities.projectiles.PlayerProjectile;

public class PlayerAttackBehavior extends EntityBehavior<Player> implements AttackBehavior {

    protected int ticksSinceAttack;
    protected Vector attackDirection = new Vector(0, 0);
    private boolean attackingUp;
    private boolean attackingLeft;
    private boolean attackingRight;
    private boolean attackingDown;

    public PlayerAttackBehavior(Player owningEntity) {
        super(owningEntity);
    }

    public boolean canAttack() {
        return !attackDirection.isZero() && ticksSinceAttack <= 0;
    }

    @Override
    public void attack() {
        int dx = 0;
        int dy = 0;
        if (attackingUp) {
            dy--;
        }
        if (attackingDown) {
            dy++;
        }
        if (attackingRight) {
            dx++;
        }
        if (attackingLeft) {
            dx--;
        }

        attackDirection = new Vector(dx, dy);

        ticksSinceAttack = Math.max(0, ticksSinceAttack - 1);
        if (!canAttack()) {
            return;
        }

        PlayerProjectile bullet = getDefaultProjectile();
        bullet.setEntityPosition(owningEntity.getDisplayNode().getBoundsInParent().getCenterX(),
                                 owningEntity.getDisplayNode().getBoundsInParent().getCenterY());

        owningEntity.getOwningRoom().getMiscEntities().add(bullet);

        ticksSinceAttack =
                (int) (owningEntity.getEntityStatistics().getModifiedAttackDelay());
    }

    protected PlayerProjectile getDefaultProjectile() {
        return new PlayerProjectile(owningEntity.getOwningRoom(),
                                    5,
                                    attackDirection,
                                    (int) (owningEntity.getEntityStatistics()
                                                       .getModifiedAttackDamage()), 2);
    }

    public void setAttackDirection(Vector attackDirection) {
        this.attackDirection = attackDirection;
    }

    public void modifyAttackDirection(Vector addition) {
        this.attackDirection = attackDirection.plus(addition).unit();
    }

    public void setAttackingUp(boolean attackingUp) {
        this.attackingUp = attackingUp;
    }

    public void setAttackingLeft(boolean attackingLeft) {
        this.attackingLeft = attackingLeft;
    }

    public void setAttackingRight(boolean attackingRight) {
        this.attackingRight = attackingRight;
    }

    public void setAttackingDown(boolean attackingDown) {
        this.attackingDown = attackingDown;
    }
}
