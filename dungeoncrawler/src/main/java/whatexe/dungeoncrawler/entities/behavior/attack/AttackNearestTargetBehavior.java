package whatexe.dungeoncrawler.entities.behavior.attack;

import whatexe.dungeoncrawler.entities.Entity;
import whatexe.dungeoncrawler.entities.behavior.EntityBehavior;
import whatexe.dungeoncrawler.entities.motionsupport.Vector;
import whatexe.dungeoncrawler.entities.projectiles.Projectile;

import java.util.List;
import java.util.function.Supplier;
import java.util.stream.Collectors;

public abstract class AttackNearestTargetBehavior<T extends Entity> extends EntityBehavior<Entity>
        implements AttackBehavior {

    private final Supplier<List<T>> targetsSuppler;
    protected int ticksSinceAttack;

    public AttackNearestTargetBehavior(Entity owningEntity, Supplier<List<T>> targetsSuppler) {
        super(owningEntity);

        this.targetsSuppler = targetsSuppler;
    }

    @Override
    public void attack() {
        ticksSinceAttack = Math.max(0, ticksSinceAttack - 1);

        List<T> targets = targetsSuppler.get();
        if (targets.size() == 0 || ticksSinceAttack > 0) {
            return;
        }

        Entity target = targets.stream().sorted((o1, o2) -> {
            if (o1.equals(o2)) {
                return 0;
            }
            if (owningEntity.vectorToOtherEntity(o1).magnitude()
                    - owningEntity.vectorToOtherEntity(o2).magnitude() < 0) {
                return -1;
            }
            return 1;
        }).collect(Collectors.toList()).get(0);

        Vector attackDirection = owningEntity.vectorToOtherEntity(target);

        Projectile bullet = getDefaultProjectile(attackDirection);
        bullet.setEntityPosition(owningEntity.getDisplayNode().getBoundsInParent().getCenterX(),
                                 owningEntity.getDisplayNode().getBoundsInParent().getCenterY());

        owningEntity.getOwningRoom().getMiscEntities().add(bullet);

        ticksSinceAttack =
                (int) (owningEntity.getEntityStatistics().getModifiedAttackDelay());
    }

    protected abstract Projectile getDefaultProjectile(Vector attackDirection);
}
