package whatexe.dungeoncrawler.entities.behavior.movement;

import whatexe.dungeoncrawler.entities.Entity;
import whatexe.dungeoncrawler.entities.motionsupport.Vector;

import java.util.List;
import java.util.function.Supplier;

public class StayCloseMovementMovementBehavior extends FollowingMovementBehavior {

    private static final int WANDER_ONE_DIRECTION_TICKS = 300;

    private final double closeDistance;
    private int wanderCurrentTicks;
    private Vector wanderCurrentVector;

    /**
     * Similar to FollowingMovementBehavior, but the owningEntity will attempt to stay at least
     * closeDistance away from any of the targets given by the targetsSupplier. In addition, it
     * will attempt to wander the room if it cannot find a target.
     *
     * @param owningEntity    the entity this behavior belongs to.
     * @param targetsSupplier a Supplier for a list of Entities that the owningEntity should
     *                        attempt to stay close to.
     * @param closeDistance   the closest distance the owningEntity will ever attempt to get to any
     *                        target.
     */
    public StayCloseMovementMovementBehavior(Entity owningEntity,
                                             Supplier<List<Entity>> targetsSupplier,
                                             double closeDistance) {
        super(owningEntity, targetsSupplier);

        this.closeDistance = closeDistance;
    }

    @Override
    public Vector getMovement() {
        Entity target = getTarget();
        if (target == null) {
            return getWanderVector();
        }
        Vector toTarget = owningEntity.vectorToOtherEntity(target);
        if (toTarget.isZero()) {
            return toTarget;
        }

        double dDistance = toTarget.magnitude() - closeDistance;
        double speed = owningEntity.getEntityStatistics().getModifiedSpeed();
        if (dDistance < 0) {
            return toTarget.unit().scaledBy(-Math.min(-dDistance, speed));
        }

        return toTarget.unit().scaledBy(Math.min(dDistance, speed));
    }

    private Vector getWanderVector() {
        if (wanderCurrentTicks > 0) {
            wanderCurrentTicks--;
            return wanderCurrentVector;
        }
        wanderCurrentTicks = WANDER_ONE_DIRECTION_TICKS;
        wanderCurrentVector = new Vector(1, 0)
                .rotatedBy(Math.random() * Math.PI * 2)
                .scaledBy(owningEntity.getEntityStatistics().getModifiedSpeed());
        return wanderCurrentVector;
    }
}
