package whatexe.dungeoncrawler.entities;

import javafx.beans.property.SimpleIntegerProperty;
import javafx.scene.Node;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.shape.Rectangle;
import whatexe.dungeoncrawler.MainApp;
import whatexe.dungeoncrawler.entities.motionsupport.Vector;
import whatexe.dungeoncrawler.layout.Room;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;

import static javafx.scene.input.KeyCode.*;


public class Player extends Entity {
    private static final double DAMAGE_DELAY = 50;

    private final SimpleIntegerProperty money;
    /**
     * A map of key bindings, mapped to boolean {@link Consumer}s. The Consumers receive true if
     * the key was pressed and false if the key was released.
     */
    private final Map<KeyCode, Consumer<Boolean>> keyBindings;

    private boolean goNorth;
    private boolean goSouth;
    private boolean goEast;
    private boolean goWest;
    private boolean attack;
    private double speed = 2;
    private double lastTick = 0;
    private Vector movementVector;

    public Player(Node displayNode) {
        super(displayNode, null);
        canTick = true;

        money = new SimpleIntegerProperty();
        keyBindings = new HashMap<>();
        movementVector = new Vector(0, 0);
    }

    public void initControls() {
        keyBindings.put(UP, pressed -> goNorth = pressed);
        keyBindings.put(W, pressed -> goNorth = pressed);
        keyBindings.put(DOWN, pressed -> goSouth = pressed);
        keyBindings.put(S, pressed -> goSouth = pressed);
        keyBindings.put(LEFT, pressed -> goWest = pressed);
        keyBindings.put(A, pressed -> goWest = pressed);
        keyBindings.put(RIGHT, pressed -> goEast = pressed);
        keyBindings.put(D, pressed -> goEast = pressed);
        keyBindings.put(SPACE, pressed -> attack = pressed);

        MainApp.getPrimaryStage().getScene().addEventFilter(KeyEvent.KEY_PRESSED, (event) -> {
            try {
                keyBindings.get(event.getCode()).accept(true);
            } catch (NullPointerException ignored) {
            }

        });

        MainApp.getPrimaryStage().getScene().addEventFilter(KeyEvent.KEY_RELEASED, (event) -> {
            try {
                keyBindings.get(event.getCode()).accept(false);
            } catch (NullPointerException ignored) {
            }
        });
    }

    public SimpleIntegerProperty moneyProperty() {
        return money;
    }

    public void setMoney(int money) {
        this.money.set(money);
    }

    public void adjustMoney(int dMoney) {
        money.set(money.getValue() + dMoney);
    }

    public void setCurrentRoom(Room currentRoom) {
        this.owningRoom = currentRoom;
    }

    public double getHeight() {
        return ((Rectangle) displayNode).getHeight();
    }

    public double getWidth() {
        return ((Rectangle) displayNode).getWidth();
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }

    public void attackEntity(Vector direction) {
        if (attack) {
            PlayerProjectile bullet = new PlayerProjectile(owningRoom, 10, 10, 5, direction);
            bullet.getDisplayNode().setTranslateX(this.getDisplayNode().getTranslateX());
            bullet.getDisplayNode().setTranslateY(this.getDisplayNode().getTranslateY());
            owningRoom.getMiscEntities().add(bullet);
        }
    }

    @Override
    protected void handleDeath() {
        try {
            MainApp.switchScene("EndScreen");
        } catch (IOException e) {
            e.printStackTrace();
            MainApp.getPrimaryStage().close();
        }
    }

    @Override
    public void tick() {
        lastTick = Math.max(0, lastTick - 1);
        int dx = 0;
        int dy = 0;
        if (goNorth) {
            dy -= speed;
        }
        if (goSouth) {
            dy += speed;
        }
        if (goEast) {
            dx += speed;
        }
        if (goWest) {
            dx -= speed;
        }

        movementVector = new Vector(dx, dy);

        moveNode(dx, dy);
        attackEntity(movementVector);
    }

    @Override
    public void adjustHealth(int dHealth) {
        if (lastTick == 0) {
            health.set(health.getValue() + dHealth);
            lastTick = DAMAGE_DELAY;
        }
    }
}
