package whatexe.dungeoncrawler.entities;

import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Bounds;
import javafx.scene.Node;
import javafx.scene.paint.Color;
import javafx.scene.shape.*;
import whatexe.dungeoncrawler.entities.behavior.BehaviorSet;
import whatexe.dungeoncrawler.entities.behavior.EntityStatistics;
import whatexe.dungeoncrawler.entities.behavior.presets.DoNothingBehaviorSet;
import whatexe.dungeoncrawler.entities.effects.StatusEffect;
import whatexe.dungeoncrawler.entities.motionsupport.Line;
import whatexe.dungeoncrawler.entities.motionsupport.Vector;
import whatexe.dungeoncrawler.layout.rooms.Room;

import java.util.function.Consumer;

public abstract class Entity {
    private static final double DAMAGE_DELAY = 50;

    private static final double EPSILON = 5e-4;
    private static final double SQRT2 = 1.4142135623730950488;
    private static final double NEAR_SCAN_TOLERANCE = 20;

    /**
     * Sprite (or otherwise) used to display the entity to a Scene Graph.
     */
    protected final Node displayNode;
    protected final Shape hitbox;
    protected final SimpleIntegerProperty health;
    protected final SimpleObjectProperty<BehaviorSet> behaviorSet;
    protected final EntityStatistics entityStatistics;
    protected final ObservableList<StatusEffect> statusEffects;
    protected Room owningRoom;
    protected boolean canTick;

    private double ticksSinceDamaged;

    public Entity(Node displayNode, Room owningRoom) {
        this(displayNode, owningRoom, new EntityStatistics());
    }

    public Entity(Node displayNode, Room owningRoom, EntityStatistics entityStatistics) {
        this(displayNode, owningRoom, 0, entityStatistics);
    }

    public Entity(Node displayNode, Room owningRoom, int startingHealth) {
        this(displayNode,
             new Rectangle(displayNode.prefWidth(-1),
                           displayNode.prefHeight(-1),
                           Color.WHITE), owningRoom, startingHealth, new EntityStatistics());
    }

    public Entity(Node displayNode,
                  Room owningRoom,
                  int startingHealth,
                  EntityStatistics entityStatistics) {
        this(displayNode,
             new Rectangle(displayNode.prefWidth(-1),
                           displayNode.prefHeight(-1),
                           Color.WHITE), owningRoom, startingHealth, entityStatistics);
    }

    public Entity(Node displayNode, Shape hitbox, Room owningRoom) {
        this(displayNode, hitbox, owningRoom, 0, new EntityStatistics());
    }

    public Entity(Node displayNode, Shape hitbox, Room owningRoom, int startingHealth,
                  EntityStatistics entityStatistics) {
        this.displayNode = displayNode;
        this.hitbox = hitbox;
        this.owningRoom = owningRoom;
        this.behaviorSet = new SimpleObjectProperty<>(new DoNothingBehaviorSet(this));
        this.entityStatistics = entityStatistics;
        this.statusEffects = FXCollections.observableArrayList();
        canTick = false;

        health = new SimpleIntegerProperty(startingHealth);
        if (startingHealth == 0) {
            health.set(entityStatistics.getMaxHealth());
        } else {
            entityStatistics.setMaxHealth(startingHealth);
        }
        health.addListener((healthNumber, oldValue, newValue) -> {
            if (newValue.intValue() <= 0) {
                handleDeath();
            }
        });
        entityStatistics.maxHealthProperty().addListener((__, oldValue, newValue) -> {
            health.set(newValue.intValue());
        });

        this.displayNode.applyCss();
        this.hitbox.applyCss();

        // Add listeners for updating the hitbox when the displayNode moves
        this.displayNode.translateXProperty().addListener((__, oldValue, newValue) -> {
            this.displayNode.applyCss();
            updateHitboxPosition();
        });
        this.displayNode.translateYProperty().addListener((__, oldValue, newValue) -> {
            this.displayNode.applyCss();
            updateHitboxPosition();
        });

        updateHitboxPosition();
    }

    public static ConstrainedVelocityPair getConstrainedVelocity(Bounds thisHitboxBounds,
                                                                 Path constraints,
                                                                 Vector attemptVelocity) {
        Vector constrainedVelocity = new Vector(0, 0);

        Bounds previousHitboxBounds = thisHitboxBounds;

        Shape predictedHitbox = new Rectangle(thisHitboxBounds.getWidth(),
                                              thisHitboxBounds.getHeight());

        predictedHitbox.setTranslateX(previousHitboxBounds.getMinX());
        predictedHitbox.setTranslateY(previousHitboxBounds.getMinY());
        Shape predictedOverlap = Shape.intersect(predictedHitbox, constraints);
        predictedOverlap.applyCss();

        // If already inside something (not good)
        if (predictedOverlap.getLayoutBounds().getWidth() > 0
                || predictedOverlap.getLayoutBounds().getHeight() > 0) {
            return new ConstrainedVelocityPair(CollisionState.INSIDE, attemptVelocity);
        }

        predictedHitbox.setTranslateX(previousHitboxBounds.getMinX() + attemptVelocity.get(0));
        predictedHitbox.setTranslateY(previousHitboxBounds.getMinY() + attemptVelocity.get(1));
        predictedHitbox.applyCss();
        predictedOverlap = Shape.intersect(predictedHitbox, constraints);
        predictedOverlap.applyCss();

        // If next step won't be an issue
        if (predictedOverlap.getLayoutBounds().getWidth() <= EPSILON
                && predictedOverlap.getLayoutBounds().getHeight() <= EPSILON) {
            return new ConstrainedVelocityPair(CollisionState.NOT_COLLIDED, attemptVelocity);
        }

        int attempts = 0;

        do {

            // Cast rays to predicted corners, find intersections
            Vector topLeft = new Vector(previousHitboxBounds.getMinX(),
                                        previousHitboxBounds.getMinY());
            Vector topRight = new Vector(previousHitboxBounds.getMaxX(),
                                         previousHitboxBounds.getMinY());
            Vector bottomRight = new Vector(previousHitboxBounds.getMaxX(),
                                            previousHitboxBounds.getMaxY());
            Vector bottomLeft = new Vector(previousHitboxBounds.getMinX(),
                                           previousHitboxBounds.getMaxY());
            Vector[] currentCorners = {topLeft, topRight, bottomRight, bottomLeft};

            Line topLeftCast = new Line(topLeft, topLeft.plus(attemptVelocity));
            Line topRightCast = new Line(topRight, topRight.plus(attemptVelocity));
            Line bottomRightCast = new Line(bottomRight, bottomRight.plus(attemptVelocity));
            Line bottomLeftCast = new Line(bottomLeft, bottomLeft.plus(attemptVelocity));
            Line[] casts = {topLeftCast, topRightCast, bottomRightCast, bottomLeftCast};

            double[] distances = {-1, -1, -1, -1};
            Vector[] intersections = new Vector[4];
            Vector[] normals = new Vector[4];

            Vector temporaryAttemptVelocity = attemptVelocity;
            forEachPathLine(constraints, line -> {
                for (int i = 0; i < 4; i++) {
                    Vector intersect = casts[i].intersectionWith(line);
                    if (intersect != null) {
                        double distance = currentCorners[i].distanceTo(intersect);
                        if (intersections[i] == null || distances[i] > distance) {
                            intersections[i] = intersect;
                            distances[i] = distance;

                            Vector normal = line.normal();
                            if (normal.dot(temporaryAttemptVelocity) > 0) {
                                // Normal facing inside isn't good
                                normals[i] = normal.scaledBy(-1);
                            } else {
                                normals[i] = normal;
                            }
                        }
                    }
                }
            });

            Vector constrainedPerpendicular = null;
            Vector parallel = null;
            double minDistance = 0;
            for (int i = 0; i < 4; i++) {
                if (intersections[i] != null && (constrainedPerpendicular == null
                        || distances[i] < minDistance)) {
                    minDistance = distances[i];

                    Vector upToLine = casts[i].tangent().unit().scaledBy(distances[i] - EPSILON);
                    constrainedPerpendicular = Line.projectVector(normals[i], upToLine);

                    parallel = Line.projectVector(upToLine.minus(constrainedPerpendicular),
                                                  attemptVelocity);
                }
            }

            if (constrainedPerpendicular == null) {
                // intersection is on a strange corner that intersects a hitbox edge
                // System.out.println("Strange intersection!");
                return new ConstrainedVelocityPair(CollisionState.STRANGE, constrainedVelocity);
            }

            if (constrainedPerpendicular.containsNaN() || constrainedPerpendicular.isZero()) {
                constrainedPerpendicular = new Vector(0, 0);
            }
            if (parallel.containsNaN() || parallel.isZero()) {
                parallel = new Vector(0, 0);
            }

            constrainedVelocity = constrainedVelocity.plus(constrainedPerpendicular);
            attemptVelocity = parallel;

            predictedHitbox.setTranslateX(
                    previousHitboxBounds.getMinX() + constrainedPerpendicular.get(0)
                            + attemptVelocity.get(0));
            predictedHitbox.setTranslateY(
                    previousHitboxBounds.getMinY() + constrainedPerpendicular.get(1)
                            + attemptVelocity.get(1));
            predictedHitbox.applyCss();

            previousHitboxBounds = predictedHitbox.getBoundsInParent();

            predictedOverlap = Shape.intersect(predictedHitbox, constraints);
            predictedOverlap.applyCss();

            attempts++;
        } while (predictedOverlap.getLayoutBounds().getWidth() > EPSILON
                && predictedOverlap.getLayoutBounds().getHeight() > EPSILON
                && attempts < 5
                && !attemptVelocity.isZero());

        return new ConstrainedVelocityPair(CollisionState.COLLIDED,
                                           constrainedVelocity.plus(attemptVelocity));
    }

    public static void forEachPathLine(Path path, Consumer<Line> lineAction) {
        Vector start = new Vector(0, 0);
        Vector previous = new Vector(0, 0);

        for (PathElement element : path.getElements()) {
            Line newLine;
            if (element instanceof MoveTo) {
                MoveTo to = (MoveTo) element;
                start = new Vector(to.getX(), to.getY());
                previous = start;
                continue;
            } else if (element instanceof LineTo) {
                LineTo to = (LineTo) element;
                Vector next = new Vector(to.getX(), to.getY());
                newLine = new Line(previous, next);

                previous = next;
            } else if (element instanceof ClosePath) {
                newLine = new Line(previous, start);

                previous = start;
            } else {
                continue;
            }

            if (newLine.getStart().isAlmost(newLine.getEnd())) {
                continue;
            }

            lineAction.accept(newLine);
        }
    }

    public void updateHitboxPosition() {
        Bounds displayNodeBounds = displayNode.getBoundsInParent();

        double dWidth = hitbox.prefWidth(-1) - displayNode.prefWidth(-1);
        double dHeight = hitbox.prefHeight(-1) - displayNode.prefHeight(-1);

        hitbox.setTranslateX(displayNodeBounds.getMinX() - dWidth * 0.5);
        hitbox.setTranslateY(displayNodeBounds.getMinY() - dHeight * 0.5);
        hitbox.applyCss();
    }

    protected void handleDeath() {
        getBehaviorSet().die();
    }

    public Node getDisplayNode() {
        return displayNode;
    }

    public boolean canTick() {
        return canTick;
    }

    public void moveNode(Vector attemptVector) {
        if (attemptVector.isZero()) {
            return;
        }

        double x = displayNode.getTranslateX();
        double y = displayNode.getTranslateY();

        final double xMin = displayNode.getParent().getLayoutBounds().getMinX();
        final double yMin = displayNode.getParent().getLayoutBounds().getMinY();
        final double xMax = displayNode.getParent().getLayoutBounds().getMaxX()
                - displayNode.getLayoutBounds().getWidth();
        final double yMax = displayNode.getParent().getLayoutBounds().getMaxY()
                - displayNode.getLayoutBounds().getHeight();

        ConstrainedVelocityPair boundaryConstrainedVelocityPair
                = getConstrainedVelocity(hitbox.getBoundsInParent(),
                                         (Path) owningRoom.getBlockedSpace(),
                                         attemptVector);
        Vector constrainedVelocity = boundaryConstrainedVelocityPair.constrainedVelocity;

        Entity closestEntity = null;
        ConstrainedVelocityPair entityConstrainedVelocityPair = null;
        for (Entity entity : getBehaviorSet().getCollisionBehavior()
                                             .getPossibleCollisionTargets()) {
            Path convertedHitbox = (Path) Shape.union(owningRoom.getBlockedSpace(),
                                                      entity.getHitbox());
            entityConstrainedVelocityPair = getConstrainedVelocity(hitbox.getBoundsInParent(),
                                                                   convertedHitbox,
                                                                   attemptVector);
            Vector testVelocity = entityConstrainedVelocityPair.constrainedVelocity;

            if (testVelocity.distanceTo(attemptVector) > constrainedVelocity.distanceTo(
                    attemptVector)) {
                constrainedVelocity = testVelocity;
                closestEntity = entity;
            }
        }

        //Ensures that the player can't move outside of the parent node bounds
        double translateX = Math.max(xMin, Math.min(x + constrainedVelocity.get(0), xMax));
        double translateY = Math.max(yMin, Math.min(y + constrainedVelocity.get(1), yMax));
        displayNode.setTranslateX(translateX);
        displayNode.setTranslateY(translateY);

        updateHitboxPosition();

        if (closestEntity != null) {
            if (entityConstrainedVelocityPair.collisionState != CollisionState.NOT_COLLIDED) {
                getBehaviorSet().handleEntityCollision(closestEntity);
            }
        } else if (boundaryConstrainedVelocityPair.collisionState != CollisionState.NOT_COLLIDED) {
            getBehaviorSet().handleBoundaryCollision();
        }
    }

    public void moveNode(double dx, double dy) {
        moveNode(new Vector(dx, dy));
    }

    public Shape getHitbox() {
        return hitbox;
    }

    public boolean isNear(Entity other) {
        if (other == null || other.hitbox == null || hitbox == null) {
            return false;
        }

        // The intent of this algorithm is to be very fast :)
        // Multiplication and addition is very quick
        Bounds thisBounds = hitbox.getLayoutBounds();
        Bounds otherBounds = other.hitbox.getLayoutBounds();

        // Create circumcircles around both entities, assuming they are square, shifted out by a
        // tolerance
        double thisScanRadius =
                Math.max(thisBounds.getHeight() * 0.5, thisBounds.getWidth() * 0.5) * SQRT2
                        + NEAR_SCAN_TOLERANCE;
        double otherScanRadius =
                Math.max(otherBounds.getHeight() * 0.5, otherBounds.getWidth() * 0.5) * SQRT2
                        + NEAR_SCAN_TOLERANCE;

        // Check if buffered circumcircles are intersecting
        double dX = displayNode.getBoundsInParent().getCenterX()
                - other.displayNode.getBoundsInParent().getCenterX();
        double dY = displayNode.getBoundsInParent().getCenterY()
                - other.displayNode.getBoundsInParent().getCenterY();

        double centerDistanceSquared = dX * dX + dY * dY;
        double radiusSumSquared =
                (thisScanRadius + otherScanRadius) * (thisScanRadius + otherScanRadius);

        return centerDistanceSquared <= radiusSumSquared;
    }

    public void setEntityPosition(double x, double y) {
        displayNode.setTranslateX(x);
        displayNode.setTranslateY(y);

        updateHitboxPosition();
    }

    public boolean checkOverlap(Entity other) {
        if (other == null || other.hitbox == null || hitbox == null) {
            return false;
        }

        Shape intersection = Shape.intersect(hitbox, other.hitbox);
        intersection.applyCss();

        return intersection.getLayoutBounds().getWidth() > 0
                && intersection.getLayoutBounds().getHeight() > 0;
    }

    public void tick() {
        ticksSinceDamaged = Math.max(0, ticksSinceDamaged - 1);

        for (int i = 0; i < statusEffects.size(); i++) {
            StatusEffect effect = statusEffects.get(i);
            effect.tick();
            if (effect.shouldRemove()) {
                statusEffects.remove(effect);
                i--;
            }
        }

        moveNode(getBehaviorSet().getMovement());

        owningRoom.addEntities(getBehaviorSet().attack());
    }

    public SimpleIntegerProperty healthProperty() {
        return health;
    }

    public void adjustHealth(int dHealth) {
        if (ticksSinceDamaged == 0) {
            health.set(Math.min(health.getValue() + dHealth, entityStatistics.getMaxHealth()));
            ticksSinceDamaged = DAMAGE_DELAY;
        }
    }

    public int getHealth() {
        return health.get();
    }

    public void setHealth(int health) {
        this.health.set(health);
    }

    public Room getOwningRoom() {
        return owningRoom;
    }

    public BehaviorSet getBehaviorSet() {
        return behaviorSet.get();
    }

    public SimpleObjectProperty<BehaviorSet> behaviorSetProperty() {
        return behaviorSet;
    }

    public Vector vectorToOtherEntity(Entity other) {
        if (other == null) {
            return new Vector(0, 0);
        }
        Bounds targetBounds = other.getHitbox().getBoundsInParent();
        Bounds thisBounds = this.getHitbox().getBoundsInParent();
        Vector targetPosition = new Vector(targetBounds.getCenterX(), targetBounds.getCenterY());
        Vector thisPosition = new Vector(thisBounds.getCenterX(), thisBounds.getCenterY());
        return targetPosition.minus(thisPosition);
    }

    public EntityStatistics getEntityStatistics() {
        return entityStatistics;
    }

    public ObservableList<StatusEffect> getStatusEffects() {
        return statusEffects;
    }

    private enum CollisionState {
        NOT_COLLIDED,
        COLLIDED,
        INSIDE,
        STRANGE
    }

    private static class ConstrainedVelocityPair {
        private final CollisionState collisionState;
        private final Vector constrainedVelocity;

        public ConstrainedVelocityPair(CollisionState collisionState,
                                       Vector constrainedVelocity) {
            this.collisionState = collisionState;
            this.constrainedVelocity = constrainedVelocity;
        }

        public CollisionState getCollisionState() {
            return collisionState;
        }

        public Vector getConstrainedVelocity() {
            return constrainedVelocity;
        }
    }
}
