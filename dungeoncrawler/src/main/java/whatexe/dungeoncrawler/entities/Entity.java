package whatexe.dungeoncrawler.entities;

import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Rectangle2D;
import javafx.scene.shape.*;
import whatexe.dungeoncrawler.entities.behavior.BehaviorSet;
import whatexe.dungeoncrawler.entities.behavior.EntityStatistics;
import whatexe.dungeoncrawler.entities.behavior.presets.DoNothingBehaviorSet;
import whatexe.dungeoncrawler.entities.effects.StatusEffect;
import whatexe.dungeoncrawler.entities.motionsupport.AABBTree;
import whatexe.dungeoncrawler.entities.motionsupport.BoundaryRectangle;
import whatexe.dungeoncrawler.entities.motionsupport.Line;
import whatexe.dungeoncrawler.entities.motionsupport.Vector;
import whatexe.dungeoncrawler.layout.rooms.Room;

import java.util.List;
import java.util.function.Consumer;

public abstract class Entity {
    private static final double DAMAGE_DELAY = 50;

    protected final SimpleObjectProperty<Rectangle2D> hitbox;
    protected final SimpleIntegerProperty health;
    protected final SimpleObjectProperty<BehaviorSet> behaviorSet;
    protected final EntityStatistics entityStatistics;
    protected final ObservableList<StatusEffect> statusEffects;
    /**
     * Sprite (or otherwise) used to display the entity to a Scene Graph.
     */
    private final SimpleObjectProperty<Sprite> displayNode;
    protected Room owningRoom;
    protected boolean canTick;

    private double ticksSinceDamaged;

    public Entity(Sprite displayNode, Room owningRoom) {
        this(displayNode, owningRoom, new EntityStatistics());
    }

    public Entity(Sprite displayNode, Room owningRoom, EntityStatistics entityStatistics) {
        this(displayNode, owningRoom, 0, entityStatistics);
    }

    public Entity(Sprite displayNode, Room owningRoom, int startingHealth) {
        this(displayNode,
             new Rectangle2D(displayNode.getTranslateX(),
                             displayNode.getTranslateY(),
                             displayNode.getWidth(),
                             displayNode.getHeight()),
             owningRoom,
             startingHealth,
             new EntityStatistics());
    }

    public Entity(Sprite displayNode,
                  Room owningRoom,
                  int startingHealth,
                  EntityStatistics entityStatistics) {
        this(displayNode,
             new Rectangle2D(displayNode.getTranslateX(),
                             displayNode.getTranslateY(),
                             displayNode.getWidth(),
                             displayNode.getHeight()),
             owningRoom,
             startingHealth,
             entityStatistics);
    }

    public Entity(Sprite displayNode, Rectangle2D hitbox, Room owningRoom) {
        this(displayNode, hitbox, owningRoom, 0, new EntityStatistics());
    }

    public Entity(Sprite displayNode, Rectangle2D hitbox, Room owningRoom, int startingHealth,
                  EntityStatistics entityStatistics) {
        this.displayNode = new SimpleObjectProperty<>(displayNode);
        this.hitbox = new SimpleObjectProperty<>(hitbox);
        this.owningRoom = owningRoom;
        this.behaviorSet = new SimpleObjectProperty<>(new DoNothingBehaviorSet(this));
        this.entityStatistics = entityStatistics;
        this.statusEffects = FXCollections.observableArrayList();
        canTick = false;

        health = new SimpleIntegerProperty(startingHealth);
        if (startingHealth == 0) {
            health.set(entityStatistics.getMaxHealth());
        } else {
            entityStatistics.setMaxHealth(startingHealth);
        }
        health.addListener((healthNumber, oldValue, newValue) -> {
            if (newValue.intValue() <= 0) {
                handleDeath();
            }
        });
        entityStatistics.maxHealthProperty().addListener((__, oldValue, newValue) -> {
            health.set(newValue.intValue());
        });

        this.displayNode.addListener((__, oldValue, newValue) -> {
            updateHitboxPosition();
        });
        getDisplayNode().viewportProperty().addListener((__, oldValue, newValue) -> {
            updateHitboxPosition();
        });

        // Add listeners for updating the hitbox when the getDisplayNode() moves
        this.getDisplayNode().translateXProperty().addListener((__, oldValue, newValue) -> {
            this.getDisplayNode().applyCss();
            updateHitboxPosition();
        });
        this.getDisplayNode().translateYProperty().addListener((__, oldValue, newValue) -> {
            this.getDisplayNode().applyCss();
            updateHitboxPosition();
        });

        updateHitboxPosition();
    }

    public static void forEachPathLine(Path path, Consumer<Line> lineAction) {
        Vector start = new Vector(0, 0);
        Vector previous = new Vector(0, 0);

        for (PathElement element : path.getElements()) {
            Line newLine;
            if (element instanceof MoveTo) {
                MoveTo to = (MoveTo) element;
                start = new Vector(to.getX(), to.getY());
                previous = start;
                continue;
            } else if (element instanceof LineTo) {
                LineTo to = (LineTo) element;
                Vector next = new Vector(to.getX(), to.getY());
                newLine = new Line(previous, next);

                previous = next;
            } else if (element instanceof ClosePath) {
                newLine = new Line(previous, start);

                previous = start;
            } else {
                continue;
            }

            if (newLine.getStart().isAlmost(newLine.getEnd())) {
                continue;
            }

            lineAction.accept(newLine);
        }
    }

    public void updateHitboxPosition() {
        getDisplayNode().applyCss();

        if (getHitbox().getWidth() == 0 || getHitbox().getHeight() == 0) {
            setHitbox(new Rectangle2D(getDisplayNode().getTranslateX(),
                                      getDisplayNode().getTranslateY(),
                                      getDisplayNode().getWidth(),
                                      getDisplayNode().getHeight()));
        }

        double dWidth = getHitbox().getWidth() - getDisplayNode().getWidth();
        double dHeight = getHitbox().getHeight() - getDisplayNode().getHeight();

        setHitbox(new Rectangle2D(getDisplayNode().getTranslateX() - dWidth * 0.5,
                                  getDisplayNode().getTranslateY() - dHeight * 0.5,
                                  getHitbox().getWidth(),
                                  getHitbox().getHeight()));
    }

    protected void handleDeath() {
        getBehaviorSet().die();
    }

    public Sprite getDisplayNode() {
        return displayNode.get();
    }

    public void setDisplayNode(Sprite displayNode) {
        this.displayNode.set(displayNode);
    }

    public SimpleObjectProperty<Sprite> displayNodeProperty() {
        return displayNode;
    }

    public boolean canTick() {
        return canTick;
    }

    public void moveNode(Vector attemptVelocity) {
        if (attemptVelocity.isZero()) {
            return;
        }

        double x = getDisplayNode().getTranslateX();
        double y = getDisplayNode().getTranslateY();

        final double xMin = getDisplayNode().getParent().getLayoutBounds().getMinX();
        final double yMin = getDisplayNode().getParent().getLayoutBounds().getMinY();
        final double xMax = getDisplayNode().getParent().getLayoutBounds().getMaxX()
                - getDisplayNode().getLayoutBounds().getWidth();
        final double yMax = getDisplayNode().getParent().getLayoutBounds().getMaxY()
                - getDisplayNode().getLayoutBounds().getHeight();

        updateHitboxPosition();

        AABBTree.ConstrainedVelocityData constrainedVelocityData =
                owningRoom.getConstrainedVelocity(this, attemptVelocity);
        Vector constrainedVelocity = constrainedVelocityData.getConstrainedVelocity();
        List<Entity> collidedWith = constrainedVelocityData.getCollidedWith();
        if (collidedWith.size() > 0) {
            if (collidedWith instanceof BoundaryRectangle) {
                getBehaviorSet().handleBoundaryCollision();
            } else {
                for (Entity collidedEntity : collidedWith) {
                    getBehaviorSet().handleEntityCollision(collidedEntity);
                }
            }
        }

        //Ensures that the player can't move outside of the parent node bounds
        double translateX = Math.max(xMin, Math.min(x + constrainedVelocity.get(0), xMax));
        double translateY = Math.max(yMin, Math.min(y + constrainedVelocity.get(1), yMax));
        getDisplayNode().setTranslateX(translateX);
        getDisplayNode().setTranslateY(translateY);
        updateHitboxPosition();
    }

    public void moveNode(double dx, double dy) {
        moveNode(new Vector(dx, dy));
    }

    public Rectangle2D getHitbox() {
        return hitbox.get();
    }

    public void setHitbox(Rectangle2D hitbox) {
        this.hitbox.set(hitbox);
    }

    public SimpleObjectProperty<Rectangle2D> hitboxProperty() {
        return hitbox;
    }

    public void setEntityPosition(double x, double y) {
        getDisplayNode().setTranslateX(x);
        getDisplayNode().setTranslateY(y);

        updateHitboxPosition();
    }

    public void tick() {
        ticksSinceDamaged = Math.max(0, ticksSinceDamaged - 1);

        for (int i = 0; i < statusEffects.size(); i++) {
            StatusEffect effect = statusEffects.get(i);
            effect.tick();
            if (effect.shouldRemove()) {
                statusEffects.remove(effect);
                i--;
            }
        }

        moveNode(getBehaviorSet().getMovement());

        owningRoom.addEntities(getBehaviorSet().attack());
    }

    public SimpleIntegerProperty healthProperty() {
        return health;
    }

    public void adjustHealth(int dHealth) {
        if (ticksSinceDamaged == 0) {
            health.set(Math.min(health.getValue() + dHealth, entityStatistics.getMaxHealth()));
            ticksSinceDamaged = DAMAGE_DELAY;
        }
    }

    public int getHealth() {
        return health.get();
    }

    public void setHealth(int health) {
        this.health.set(health);
    }

    public Room getOwningRoom() {
        return owningRoom;
    }

    public BehaviorSet getBehaviorSet() {
        return behaviorSet.get();
    }

    public SimpleObjectProperty<BehaviorSet> behaviorSetProperty() {
        return behaviorSet;
    }

    public Vector vectorToOtherEntity(Entity other) {
        if (other == null) {
            return new Vector(0, 0);
        }
        Rectangle2D targetBounds = other.getHitbox();
        Rectangle2D thisBounds = this.getHitbox();

        Vector targetPosition = new Vector(targetBounds.getMinX() + targetBounds.getWidth() / 2,
                                           targetBounds.getMinY() + targetBounds.getHeight() / 2);
        Vector thisPosition = new Vector(thisBounds.getMinX() + thisBounds.getWidth() / 2,
                                         thisBounds.getMinY() + thisBounds.getHeight() / 2);

        return targetPosition.minus(thisPosition);
    }

    public EntityStatistics getEntityStatistics() {
        return entityStatistics;
    }

    public ObservableList<StatusEffect> getStatusEffects() {
        return statusEffects;
    }
}
