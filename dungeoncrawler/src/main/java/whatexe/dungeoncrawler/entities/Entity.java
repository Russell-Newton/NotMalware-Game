package whatexe.dungeoncrawler.entities;

import javafx.geometry.Bounds;
import javafx.scene.Node;
import javafx.scene.paint.Color;
import javafx.scene.shape.Path;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.Shape;
import whatexe.dungeoncrawler.layout.Room;
import whatexe.linalg.PathUtils;
import whatexe.linalg.Vector;

public abstract class Entity {

    private static final double SQRT2 = 1.4142135623730950488;
    private static final double NEAR_SCAN_TOLERANCE = 20;

    /**
     * Sprite (or otherwise) used to display the entity to a Scene Graph.
     */
    protected final Node displayNode;
    protected final Shape hitbox;
    protected Room owningRoom;
    protected boolean canTick;

    public Entity(Node displayNode, Room owningRoom) {
        this.displayNode = displayNode;
        this.owningRoom = owningRoom;
        canTick = false;

        this.displayNode.applyCss();
        hitbox = new Rectangle(this.displayNode.prefWidth(-1),
                               this.displayNode.prefHeight(-1),
                               Color.WHITE);
        hitbox.applyCss();

        updateHitboxPosition();

    }

    public void updateHitboxPosition() {
        Bounds displayNodeBounds = displayNode.getBoundsInParent();

        double dWidth = hitbox.prefWidth(-1) - displayNode.prefWidth(-1);
        double dHeight = hitbox.prefHeight(-1) - displayNode.prefHeight(-1);

        hitbox.setTranslateX(displayNodeBounds.getMinX() - dWidth * 0.5);
        hitbox.setTranslateY(displayNodeBounds.getMinY() - dHeight * 0.5);
        hitbox.applyCss();
    }

    public Entity(Node displayNode, Shape hitbox, Room owningRoom) {
        this.displayNode = displayNode;
        this.hitbox = hitbox;
        this.owningRoom = owningRoom;
        canTick = false;

        this.displayNode.applyCss();
        this.hitbox.applyCss();

        updateHitboxPosition();
    }

    public Node getDisplayNode() {
        return displayNode;
    }

    public Shape getHitbox() {
        return hitbox;
    }

    public boolean canTick() {
        return canTick;
    }

    public void moveNode(double dx, double dy) {
        if (dx == 0 && dy == 0) {
            return;
        }

        double x = displayNode.getTranslateX();
        double y = displayNode.getTranslateY();

        final double xMin = displayNode.getParent().getLayoutBounds().getMinX();
        final double yMin = displayNode.getParent().getLayoutBounds().getMinY();
        final double xMax = displayNode.getParent().getLayoutBounds().getMaxX()
                - displayNode.getLayoutBounds().getWidth();
        final double yMax = displayNode.getParent().getLayoutBounds().getMaxY()
                - displayNode.getLayoutBounds().getHeight();


        Vector constrainedVelocity =
                PathUtils.getConstrainedVelocity(hitbox.getBoundsInParent(),
                                                 (Path) owningRoom.getBlockedSpace(),
                                                 new Vector(dx, dy));

        //Ensures that the player can't move outside of the parent node bounds
        double translateX = Math.max(xMin, Math.min(x + constrainedVelocity.get(0), xMax));
        double translateY = Math.max(yMin, Math.min(y + constrainedVelocity.get(1), yMax));
        displayNode.setTranslateX(translateX);
        displayNode.setTranslateY(translateY);

        updateHitboxPosition();

        if (!constrainedVelocity.equals(new Vector(dx, dy))) {
            handleOnBoundaryCollision();
        }
    }

    public void setEntityPosition(double x, double y) {
        displayNode.setTranslateX(x);
        displayNode.setTranslateY(y);

        updateHitboxPosition();
    }

    public boolean checkOverlap(Entity other) {
        if (other == null || other.hitbox == null || hitbox == null) {
            return false;
        }

        Shape intersection = Shape.intersect(hitbox, other.hitbox);
        intersection.applyCss();

        return intersection.getLayoutBounds().getWidth() > 0
                && intersection.getLayoutBounds().getHeight() > 0;
    }

    public abstract void tick(long now);

    public void handleOnBoundaryCollision() {
        // Perform some action
    }

    public boolean isNear(Entity other) {
        if (other == null || other.hitbox == null || hitbox == null) {
            return false;
        }

        // The intent of this algorithm is to be very fast :)
        // Multiplication and addition is very quick
        Bounds thisBounds = hitbox.getLayoutBounds();
        Bounds otherBounds = other.hitbox.getLayoutBounds();

        // Create circumcircles around both entities, assuming they are square, shifted out by a
        // tolerance
        double thisScanRadius =
                Math.max(thisBounds.getHeight() * 0.5, thisBounds.getWidth() * 0.5) * SQRT2
                        + NEAR_SCAN_TOLERANCE;
        double otherScanRadius =
                Math.max(otherBounds.getHeight() * 0.5, otherBounds.getWidth() * 0.5) * SQRT2
                        + NEAR_SCAN_TOLERANCE;

        // Check if buffered circumcircles are intersecting
        double dX = displayNode.getBoundsInParent().getCenterX()
                - other.displayNode.getBoundsInParent().getCenterX();
        double dY = displayNode.getBoundsInParent().getCenterY()
                - other.displayNode.getBoundsInParent().getCenterY();

        double centerDistanceSquared = dX * dX + dY * dY;
        double radiusSumSquared =
                (thisScanRadius + otherScanRadius) * (thisScanRadius + otherScanRadius);

        return centerDistanceSquared <= radiusSumSquared;
    }
}
