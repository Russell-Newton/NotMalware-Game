package whatexe.dungeoncrawler.entities;

import javafx.beans.property.SimpleIntegerProperty;
import javafx.geometry.Bounds;
import javafx.scene.Node;
import javafx.scene.paint.Color;
import javafx.scene.shape.*;
import whatexe.dungeoncrawler.entities.motionsupport.Line;
import whatexe.dungeoncrawler.entities.motionsupport.Vector;
import whatexe.dungeoncrawler.layout.Room;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Supplier;

public abstract class Entity {

    private static final double EPSILON = 5e-4;
    private static final double SQRT2 = 1.4142135623730950488;
    private static final double NEAR_SCAN_TOLERANCE = 20;

    /**
     * Sprite (or otherwise) used to display the entity to a Scene Graph.
     */
    protected final Node displayNode;
    protected final Shape hitbox;
    protected final SimpleIntegerProperty health;
    protected Room owningRoom;
    protected boolean canTick;

    public Entity(Node displayNode, Room owningRoom) {
        this(displayNode, owningRoom, 0);

    }

    public Entity(Node displayNode, Room owningRoom, int startingHealth) {
        this(displayNode,
             new Rectangle(displayNode.prefWidth(-1),
                           displayNode.prefHeight(-1),
                           Color.WHITE), owningRoom, startingHealth);
    }

    public Entity(Node displayNode, Shape hitbox, Room owningRoom, int startingHealth) {
        this.displayNode = displayNode;
        this.hitbox = hitbox;
        this.owningRoom = owningRoom;
        canTick = false;

        health = new SimpleIntegerProperty(startingHealth);
        health.addListener(
                (healthNumber, oldValue, newValue) -> {
                    if ((double) newValue <= 0.0) {
                        handleDeath();
                    }
                }
                          );

        this.displayNode.applyCss();
        this.hitbox.applyCss();

        updateHitboxPosition();

    }

    public void updateHitboxPosition() {
        Bounds displayNodeBounds = displayNode.getBoundsInParent();

        double dWidth = hitbox.prefWidth(-1) - displayNode.prefWidth(-1);
        double dHeight = hitbox.prefHeight(-1) - displayNode.prefHeight(-1);

        hitbox.setTranslateX(displayNodeBounds.getMinX() - dWidth * 0.5);
        hitbox.setTranslateY(displayNodeBounds.getMinY() - dHeight * 0.5);
        hitbox.applyCss();
    }

    public Entity(Node displayNode, Shape hitbox, Room owningRoom) {
        this(displayNode, hitbox, owningRoom, 0);
    }

    public Node getDisplayNode() {
        return displayNode;
    }

    public boolean canTick() {
        return canTick;
    }

    public void moveNode(double dx, double dy) {
        if (dx == 0 && dy == 0) {
            return;
        }

        double x = displayNode.getTranslateX();
        double y = displayNode.getTranslateY();
        Vector attemptVector = new Vector(dx, dy);

        final double xMin = displayNode.getParent().getLayoutBounds().getMinX();
        final double yMin = displayNode.getParent().getLayoutBounds().getMinY();
        final double xMax = displayNode.getParent().getLayoutBounds().getMaxX()
                - displayNode.getLayoutBounds().getWidth();
        final double yMax = displayNode.getParent().getLayoutBounds().getMaxY()
                - displayNode.getLayoutBounds().getHeight();

        Vector constrainedVelocity = getConstrainedVelocity(hitbox.getBoundsInParent(),
                                                            (Path) owningRoom.getBlockedSpace(),
                                                            attemptVector);

        Entity closestEntity = null;
        for (Entity entity : collidableEntitySupplier().get()) {
            Path convertedHitbox = (Path) Shape.union(owningRoom.getBlockedSpace(),
                                                      entity.getHitbox());
            Vector testVelocity = getConstrainedVelocity(hitbox.getBoundsInParent(),
                                                         convertedHitbox,
                                                         attemptVector);

            if (testVelocity.distanceTo(attemptVector) > constrainedVelocity.distanceTo(
                    attemptVector)) {
                constrainedVelocity = testVelocity;
                closestEntity = entity;
            }
        }

        //Ensures that the player can't move outside of the parent node bounds
        double translateX = Math.max(xMin, Math.min(x + constrainedVelocity.get(0), xMax));
        double translateY = Math.max(yMin, Math.min(y + constrainedVelocity.get(1), yMax));
        displayNode.setTranslateX(translateX);
        displayNode.setTranslateY(translateY);

        updateHitboxPosition();

        if (!constrainedVelocity.equals(attemptVector)) {
            if (closestEntity != null) {
                handleOnEntityCollision(closestEntity);
            } else {
                handleOnBoundaryCollision();
            }
        }
    }

    public static Vector getConstrainedVelocity(Bounds thisHitboxBounds,
                                                Path constraints,
                                                Vector attemptVelocity) {
        Vector constrainedVelocity = new Vector(0, 0);

        Bounds previousHitboxBounds = thisHitboxBounds;

        Shape predictedHitbox = new Rectangle(thisHitboxBounds.getWidth(),
                                              thisHitboxBounds.getHeight());

        predictedHitbox.setTranslateX(previousHitboxBounds.getMinX());
        predictedHitbox.setTranslateY(previousHitboxBounds.getMinY());
        Shape predictedOverlap = Shape.intersect(predictedHitbox, constraints);
        predictedOverlap.applyCss();

        // If already inside something (not good)
        if (predictedOverlap.getLayoutBounds().getWidth() > 0
                || predictedOverlap.getLayoutBounds().getHeight() > 0) {
            return attemptVelocity;
        }

        predictedHitbox.setTranslateX(previousHitboxBounds.getMinX() + attemptVelocity.get(0));
        predictedHitbox.setTranslateY(previousHitboxBounds.getMinY() + attemptVelocity.get(1));
        predictedHitbox.applyCss();
        predictedOverlap = Shape.intersect(predictedHitbox, constraints);
        predictedOverlap.applyCss();

        // If next step won't be an issue
        if (predictedOverlap.getLayoutBounds().getWidth() <= EPSILON
                && predictedOverlap.getLayoutBounds().getHeight() <= EPSILON) {
            return attemptVelocity;
        }

        int attempts = 0;

        do {

            // Cast rays to predicted corners, find intersections
            Vector topLeft = new Vector(previousHitboxBounds.getMinX(),
                                        previousHitboxBounds.getMinY());
            Vector topRight = new Vector(previousHitboxBounds.getMaxX(),
                                         previousHitboxBounds.getMinY());
            Vector bottomRight = new Vector(previousHitboxBounds.getMaxX(),
                                            previousHitboxBounds.getMaxY());
            Vector bottomLeft = new Vector(previousHitboxBounds.getMinX(),
                                           previousHitboxBounds.getMaxY());
            Vector[] currentCorners = {topLeft, topRight, bottomRight, bottomLeft};

            Line topLeftCast = new Line(topLeft, topLeft.plus(attemptVelocity));
            Line topRightCast = new Line(topRight, topRight.plus(attemptVelocity));
            Line bottomRightCast = new Line(bottomRight, bottomRight.plus(attemptVelocity));
            Line bottomLeftCast = new Line(bottomLeft, bottomLeft.plus(attemptVelocity));
            Line[] casts = {topLeftCast, topRightCast, bottomRightCast, bottomLeftCast};

            double[] distances = {-1, -1, -1, -1};
            Vector[] intersections = new Vector[4];
            Vector[] normals = new Vector[4];

            Vector temporaryAttemptVelocity = attemptVelocity;
            forEachPathLine(constraints, line -> {
                for (int i = 0; i < 4; i++) {
                    Vector intersect = casts[i].intersectionWith(line);
                    if (intersect != null) {
                        double distance = currentCorners[i].distanceTo(intersect);
                        if (intersections[i] == null || distances[i] > distance) {
                            intersections[i] = intersect;
                            distances[i] = distance;

                            Vector normal = line.normal();
                            if (normal.dot(temporaryAttemptVelocity) > 0) {
                                // Normal facing inside isn't good
                                normals[i] = normal.scaledBy(-1);
                            } else {
                                normals[i] = normal;
                            }
                        }
                    }
                }
            });

            Vector constrainedPerpendicular = null;
            Vector parallel = null;
            double minDistance = 0;
            for (int i = 0; i < 4; i++) {
                if (intersections[i] != null && (constrainedPerpendicular == null
                        || distances[i] < minDistance)) {
                    minDistance = distances[i];

                    Vector upToLine = casts[i].tangent().unit().scaledBy(distances[i] - EPSILON);
                    constrainedPerpendicular = Line.projectVector(normals[i], upToLine);

                    parallel = Line.projectVector(upToLine.minus(constrainedPerpendicular),
                                                  attemptVelocity);
                }
            }

            if (constrainedPerpendicular == null) {
                // intersection is on a strange corner that intersects a hitbox edge
                // System.out.println("Strange intersection!");
                return constrainedVelocity;
            }

            if (constrainedPerpendicular.containsNaN() || constrainedPerpendicular.isZero()) {
                constrainedPerpendicular = new Vector(0, 0);
            }
            if (parallel.containsNaN() || parallel.isZero()) {
                parallel = new Vector(0, 0);
            }

            constrainedVelocity = constrainedVelocity.plus(constrainedPerpendicular);
            attemptVelocity = parallel;

            predictedHitbox.setTranslateX(
                    previousHitboxBounds.getMinX() + constrainedPerpendicular.get(0)
                            + attemptVelocity.get(0));
            predictedHitbox.setTranslateY(
                    previousHitboxBounds.getMinY() + constrainedPerpendicular.get(1)
                            + attemptVelocity.get(1));
            predictedHitbox.applyCss();

            previousHitboxBounds = predictedHitbox.getBoundsInParent();

            predictedOverlap = Shape.intersect(predictedHitbox, constraints);
            predictedOverlap.applyCss();

            attempts++;
        } while (predictedOverlap.getLayoutBounds().getWidth() > EPSILON
                && predictedOverlap.getLayoutBounds().getHeight() > EPSILON
                && attempts < 5
                && !attemptVelocity.isZero());

        return constrainedVelocity.plus(attemptVelocity);
    }

    public Supplier<List<Entity>> collidableEntitySupplier() {
        return ArrayList::new;
    }

    public Shape getHitbox() {
        return hitbox;
    }

    public void handleOnEntityCollision(Entity other) {
        // Perform some action
    }

    public void handleOnBoundaryCollision() {
        // Perform some action
    }

    public static void forEachPathLine(Path path, Consumer<Line> lineAction) {
        Vector start = new Vector(0, 0);
        Vector previous = new Vector(0, 0);

        for (PathElement element : path.getElements()) {
            Line newLine;
            if (element instanceof MoveTo) {
                MoveTo to = (MoveTo) element;
                start = new Vector(to.getX(), to.getY());
                previous = start;
                continue;
            } else if (element instanceof LineTo) {
                LineTo to = (LineTo) element;
                Vector next = new Vector(to.getX(), to.getY());
                newLine = new Line(previous, next);

                previous = next;
            } else if (element instanceof ClosePath) {
                newLine = new Line(previous, start);

                previous = start;
            } else {
                continue;
            }

            if (newLine.getStart().isAlmost(newLine.getEnd())) {
                continue;
            }

            lineAction.accept(newLine);
        }
    }

    public boolean isNear(Entity other) {
        if (other == null || other.hitbox == null || hitbox == null) {
            return false;
        }

        // The intent of this algorithm is to be very fast :)
        // Multiplication and addition is very quick
        Bounds thisBounds = hitbox.getLayoutBounds();
        Bounds otherBounds = other.hitbox.getLayoutBounds();

        // Create circumcircles around both entities, assuming they are square, shifted out by a
        // tolerance
        double thisScanRadius =
                Math.max(thisBounds.getHeight() * 0.5, thisBounds.getWidth() * 0.5) * SQRT2
                        + NEAR_SCAN_TOLERANCE;
        double otherScanRadius =
                Math.max(otherBounds.getHeight() * 0.5, otherBounds.getWidth() * 0.5) * SQRT2
                        + NEAR_SCAN_TOLERANCE;

        // Check if buffered circumcircles are intersecting
        double dX = displayNode.getBoundsInParent().getCenterX()
                - other.displayNode.getBoundsInParent().getCenterX();
        double dY = displayNode.getBoundsInParent().getCenterY()
                - other.displayNode.getBoundsInParent().getCenterY();

        double centerDistanceSquared = dX * dX + dY * dY;
        double radiusSumSquared =
                (thisScanRadius + otherScanRadius) * (thisScanRadius + otherScanRadius);

        return centerDistanceSquared <= radiusSumSquared;
    }

    public void setEntityPosition(double x, double y) {
        displayNode.setTranslateX(x);
        displayNode.setTranslateY(y);

        updateHitboxPosition();
    }

    public boolean checkOverlap(Entity other) {
        if (other == null || other.hitbox == null || hitbox == null) {
            return false;
        }

        Shape intersection = Shape.intersect(hitbox, other.hitbox);
        intersection.applyCss();

        return intersection.getLayoutBounds().getWidth() > 0
                && intersection.getLayoutBounds().getHeight() > 0;
    }

    public abstract void tick();

    public SimpleIntegerProperty healthProperty() {
        return health;
    }

    public void setHealth(int health) {
        this.health.set(health);
    }

    public void adjustHealth(int dHealth) {
        health.set(health.getValue() + dHealth);
    }

    protected void handleDeath() {
        // remove from owning room
    }
}
