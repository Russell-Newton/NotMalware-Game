package whatexe.dungeoncrawler.controllers;

import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.SubScene;
import javafx.scene.control.Button;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import whatexe.dungeoncrawler.MainApp;
import whatexe.dungeoncrawler.ManagedController;
import whatexe.dungeoncrawler.SceneManager;
import whatexe.dungeoncrawler.entities.Door;
import whatexe.dungeoncrawler.entities.Player;
import whatexe.dungeoncrawler.layout.*;

import java.io.IOException;
import java.util.Map;
import java.util.function.BiFunction;

public class LevelController extends ManagedController {
    /*
    TODO - For Jun:
        - Player reference should be initialized based on whatever difficulty is passed into the
            init(Map) method.
        - There should be a difficulty reference saved as well.
        - FXML should have display representations for Player health and money.
        - FXML representations should update with Player health and money SimpleIntegerProperties
            (a binding is your best bet).
     */

    /**
     * Encodes information of a {@link LevelController} and {@link RoomPosition} into a
     * consistent, unique String that can be used to add scenes to the {@link SceneManager}.
     */
    private static final BiFunction<LevelController, RoomPosition, String>
            SCENE_NAME_ENCODER = LevelController::encodeSceneName;

    @FXML
    protected StackPane parentPane;
    @FXML
    protected SubScene roomSubScene;

    protected String currentRoomSceneName;
    protected Player player;
    protected Room currentRoom;
    private Level level;

    public LevelController() {
        currentRoomSceneName = null;
        currentRoom = null;
        level = null;

        player = new Player(new Rectangle(20, 20, Color.BLUE));
    }

    private static String encodeSceneName(LevelController levelController,
                                          RoomPosition roomPosition) {
        return System.identityHashCode(levelController) + roomPosition.toString();
    }

    @Override
    public void init(Map<String, Object> loadParameters) {
        player = (Player) loadParameters.getOrDefault("player", player);

        init();
    }

    @Override
    public void init() {
        roomSubScene.widthProperty().bind(parentPane.prefWidthProperty());
        roomSubScene.heightProperty().bind(parentPane.prefHeightProperty());

        // roomSubScene.widthProperty().bindBidirectional(parentPane.prefWidthProperty());
        // roomSubScene.heightProperty().bindBidirectional(parentPane.prefHeightProperty());

        //initialize Level
        level = new SimpleLevelGenerator().generate();
        level.currentRoomPositionProperty()
             .addListener((observer, oldValue, newValue) -> updateRoom());

        // Add scenes to SceneManger
        for (RoomPosition position : level.getMaze().keySet()) {
            SceneManager.getInstance().addScene(SCENE_NAME_ENCODER.apply(this, position),
                                                getClass().getResource("RoomDisplay.fxml"));
        }
    }

    @Override
    public void postInit() {
        player.initControls();
        updateRoom();
        MainApp.getPrimaryStage().sizeToScene();
    }

    public void updateRoom() {
        if (currentRoom != null) {
            currentRoom.setPlayer(null);
            currentRoom.stopTicking();
        }
        currentRoom = level.getCurrentRoom();

        if (currentRoomSceneName != null) {
            SceneManager.getInstance().unloadScene(currentRoomSceneName);
        }
        currentRoomSceneName =
                SCENE_NAME_ENCODER.apply(this, level.currentRoomPositionProperty().get());

        try {
            roomSubScene.setRoot(SceneManager.getInstance()
                                             .loadParent(currentRoomSceneName,
                                                         Map.of("room", currentRoom)));

        } catch (IOException e) {
            throw new RuntimeException("Cannot load next room! " + currentRoomSceneName);
        }

        parentPane.prefWidthProperty().bind(((Pane) roomSubScene.getRoot()).prefWidthProperty());
        parentPane.prefHeightProperty().bind(((Pane) roomSubScene.getRoot()).prefHeightProperty());

        // TODO - why is this necessary??
        Button tempControl = new Button("temp");
        parentPane.getChildren().add(tempControl);
        parentPane.getChildren().remove(tempControl);

        adjustPlayerPosition();
        currentRoom.setPlayer(player);
        currentRoom.startTicking();
    }

    public Level getLevel() {
        return level;
    }

    /**
     * When the player moves to the next room, it adjusts the player position so it looks like
     * they come out of that door
     *
     * NOTE: This assumes that the doors are buttons. This method is going to have to change once
     * we change what the doors actually are!!!
     */
     private void adjustPlayerPosition() {
        if (level.getPreviousRoomPosition() == null) {
            player.setEntityPosition(roomSubScene.getWidth() / 2, roomSubScene.getHeight() / 2);
            System.out.println("Null lol");
        } else {
            double playerX = 0;
            double playerY = 0;
            ObservableList<Door> doors = currentRoom.getDoors();
            if (level.getPreviousRoomPosition().getX() == level.getRoomPosition().getX()) {
                if (level.getPreviousRoomPosition().getY() > level.getRoomPosition().getY()) {
                    //Exit door at bottom
                    Door playerExitDoor = Door.getDoorFromList(doors, Direction.DOWN);
                    playerX = playerExitDoor.getDisplayNode().getTranslateX() +
                            ((Button)playerExitDoor.getDisplayNode()).getPrefWidth() / 2 - (player.getWidth() / 2);
                    playerY =
                            playerExitDoor.getDisplayNode().getTranslateY() - player.getHeight() - 1;
                } else {
                    //Exit door at top
                    Door playerExitDoor = Door.getDoorFromList(doors, Direction.UP);
                    playerX = playerExitDoor.getDisplayNode().getTranslateX() +
                            ((Button)playerExitDoor.getDisplayNode()).getPrefWidth() / 2 - (player.getWidth() / 2);
                    playerY =
                            playerExitDoor.getDisplayNode().getTranslateY() +
                                    ((Button) playerExitDoor.getDisplayNode()).getPrefHeight() + 1;
                }
            } else {
                if (level.getPreviousRoomPosition().getX() > level.getRoomPosition().getX()) {
                    //Exit door on the right
                    Door playerExitDoor = Door.getDoorFromList(doors, Direction.RIGHT);
                    playerX =
                            playerExitDoor.getDisplayNode().getTranslateX() - player.getWidth() - 1;
                    playerY = playerExitDoor.getDisplayNode().getTranslateY() +
                            ((Button)playerExitDoor.getDisplayNode()).getPrefHeight() / 2 - (player.getHeight() / 2);
                } else {
                    //Exit door on the left
                    Door playerExitDoor = Door.getDoorFromList(doors, Direction.LEFT);
                    playerX =
                            playerExitDoor.getDisplayNode().getTranslateX() +
                                    ((Button) playerExitDoor.getDisplayNode()).getPrefWidth() + 1;
                    playerY = playerExitDoor.getDisplayNode().getTranslateY() +
                            ((Button)playerExitDoor.getDisplayNode()).getPrefHeight() / 2 - (player.getHeight() / 2);
                }
            }
            player.setEntityPosition(playerX, playerY);
        }

    }


}
