package whatexe.dungeoncrawler.controllers;

import javafx.fxml.FXML;
import javafx.scene.SubScene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ProgressBar;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import whatexe.dungeoncrawler.Difficulty;
import whatexe.dungeoncrawler.MainApp;
import whatexe.dungeoncrawler.ManagedController;
import whatexe.dungeoncrawler.SceneManager;
import whatexe.dungeoncrawler.entities.Player;
import whatexe.dungeoncrawler.entities.doors.Door;
import whatexe.dungeoncrawler.layout.Direction;
import whatexe.dungeoncrawler.layout.Level;
import whatexe.dungeoncrawler.layout.generation.RoomPosition;
import whatexe.dungeoncrawler.layout.generation.SimpleLevelGenerator;
import whatexe.dungeoncrawler.layout.rooms.Room;

import java.io.IOException;
import java.util.Map;
import java.util.function.BiFunction;

public class LevelController extends ManagedController {

    /**
     * Encodes information of a {@link LevelController} and {@link RoomPosition} into a
     * consistent, unique String that can be used to add scenes to the {@link SceneManager}.
     */
    private static final BiFunction<LevelController, RoomPosition, String>
            SCENE_NAME_ENCODER = LevelController::encodeSceneName;

    @FXML
    protected AnchorPane parentPane;
    @FXML
    protected SubScene roomSubScene;
    @FXML
    protected Text minimapText;
    protected String currentRoomSceneName;
    protected Player player;
    protected Room currentRoom;
    @FXML
    private Label healthLabel;
    @FXML
    private ProgressBar healthBar;
    @FXML
    private Label moneyLabel;
    private Level level;

    private Difficulty difficulty = Difficulty.NORMAL;

    public LevelController() {
        currentRoomSceneName = null;
        currentRoom = null;
        level = null;

        player = new Player(new Rectangle(20, 20, Color.BLUE));
    }

    private static String encodeSceneName(LevelController levelController,
                                          RoomPosition roomPosition) {
        return System.identityHashCode(levelController) + roomPosition.toString();
    }

    @Override
    public void init(Map<String, Object> loadParameters) {
        player = (Player) loadParameters.getOrDefault("player", player);
        difficulty = (Difficulty) loadParameters.getOrDefault("difficulty", Difficulty.NORMAL);
        init();
    }

    @Override
    public void init() {
        roomSubScene.widthProperty().bind(parentPane.prefWidthProperty());
        roomSubScene.heightProperty().bind(parentPane.prefHeightProperty());

        //initialize Level
        level = new SimpleLevelGenerator().generate();
        level.currentRoomPositionProperty()
             .addListener((observer, oldValue, newValue) -> updateRoom(oldValue, newValue));

        minimapText.setFont(Font.font(java.awt.Font.MONOSPACED, FontWeight.BOLD, 20));
        // AnchorPane.setRightAnchor(minimapText, 50.);
        // AnchorPane.setBottomAnchor(minimapText, 25.);

        // Add scenes to SceneManger
        for (RoomPosition position : level.getMaze().keySet()) {
            SceneManager.getInstance().addScene(SCENE_NAME_ENCODER.apply(this, position),
                                                getClass().getResource("RoomDisplay.fxml"));
        }

        initPlayer();

        SceneManager.getInstance().addScene("EndScreen",
                                            getClass().getResource("EndScreen.fxml"));
    }

    @Override
    public void postInit() {
        player.initControls();
        updateRoom(null, level.getRoomPosition());
        currentRoom.initKillButton();
        MainApp.getPrimaryStage().sizeToScene();
    }

    private void updateRoom(RoomPosition oldValue, RoomPosition newValue) {
        if (currentRoom != null) {
            currentRoom.setPlayer(null);
            currentRoom.stopTicking();
        }
        currentRoom = level.getCurrentRoom();

        if (currentRoomSceneName != null) {
            SceneManager.getInstance().unloadScene(currentRoomSceneName);
        }
        currentRoomSceneName =
                SCENE_NAME_ENCODER.apply(this, newValue);


        try {
            roomSubScene.setRoot(SceneManager.getInstance()
                                             .loadParent(currentRoomSceneName,
                                                         Map.of("room", currentRoom)));

        } catch (IOException e) {
            throw new RuntimeException("Cannot load next room! " + currentRoomSceneName);
        }

        currentRoom.initKillButton();
        currentRoom.updateDoorLocks();
        parentPane.prefWidthProperty().bind(((Pane) roomSubScene.getRoot()).prefWidthProperty());
        parentPane.prefHeightProperty().bind(((Pane) roomSubScene.getRoot()).prefHeightProperty());

        // TODO - why is this necessary??
        Button tempControl = new Button("temp");
        parentPane.getChildren().add(tempControl);
        parentPane.getChildren().remove(tempControl);

        minimapText.setText(level.mazeToString());

        relocateText();

        adjustPlayerIncomingPosition(oldValue, newValue);

        currentRoom.setPlayer(player);
        currentRoom.startTicking();
    }

    protected void initPlayer() {
        int startingHealth;
        int startingMoney;
        healthLabel.setTextFill(Color.LIGHTBLUE);
        moneyLabel.setTextFill(Color.GOLD);
        if (difficulty == Difficulty.EASY) {
            startingHealth = 100;
            startingMoney = 50;
        } else if (difficulty == Difficulty.NORMAL) {
            startingHealth = 50;
            startingMoney = 25;
        } else {
            startingHealth = 20;
            startingMoney = 10;
        }
        healthBar.setProgress(1);
        player.healthProperty().addListener((text, oldValue, newValue) -> {
            double currentHealth = (int) newValue;
            healthBar.setProgress(currentHealth / (startingHealth));
        });


        player.setHealth(startingHealth);
        healthLabel.setText(
                "Health: " + player.healthProperty().getValue() + " / " + startingHealth);
        player.healthProperty().addListener((text, oldValue, newValue) ->
                                                    healthLabel.setText("Health: "
                                                                                + newValue + " / "
                                                                                + startingHealth));
        player.setMoney(startingMoney);
        moneyLabel.setText("Money: " + player.moneyProperty().getValue() + " / " + startingMoney);
        player.moneyProperty().addListener((text, oldValue, newValue) ->
                                                   moneyLabel.setText("Money: " + newValue + " / "
                                                                              + startingMoney));
    }

    private void relocateText() {
        minimapText.setLayoutX(parentPane.getPrefWidth()
                                       - parentPane.getPadding().getRight()
                                       - minimapText.getLayoutBounds().getWidth());
        minimapText.setLayoutY(parentPane.getPrefHeight()
                                       - parentPane.getPadding().getBottom()
                                       - minimapText.getLayoutBounds().getHeight());

        healthLabel.setLayoutX(parentPane.getPadding().getLeft()
                                       + healthLabel.getPadding().getLeft());
        healthLabel.setLayoutY(parentPane.getPadding().getTop()
                                       + healthLabel.getPadding().getTop());
        healthBar.setLayoutX(parentPane.getPadding().getLeft()
                                     + healthBar.getPadding().getLeft());
        healthBar.setLayoutY(healthLabel.getLayoutY()
                                     + healthLabel.getHeight()
                                     + healthLabel.getPadding().getBottom()
                                     + healthBar.getPadding().getTop());

        moneyLabel.setLayoutX(parentPane.getPrefWidth()
                                      - parentPane.getPadding().getRight()
                                      - moneyLabel.getWidth()
                                      - moneyLabel.getPadding().getRight());
        moneyLabel.setLayoutY(parentPane.getPadding().getTop()
                                      + moneyLabel.getPadding().getTop());
    }

    /**
     * When the player moves to the next room, it adjusts the player position so it looks like
     * they come out of that door
     * <p>
     * NOTE: This assumes that the doors are buttons. This method is going to have to change once
     * we change what the doors actually are!!!
     *
     * @param lastRoom the position of the room last visited
     * @param newRoom  the position of the room just entering
     */
    private void adjustPlayerIncomingPosition(RoomPosition lastRoom, RoomPosition newRoom) {
        if (lastRoom == null) {
            player.setEntityPosition(roomSubScene.getWidth() / 2, roomSubScene.getHeight() / 2);
            // System.out.println("Null lol");
            return;
        }
        Direction moveDirection = RoomPosition.getPrimaryDirectionFrom(newRoom, lastRoom);
        Door playerExitDoor = Door.getDoorFromList(currentRoom.getDoors(), moveDirection);
        Button doorNode = (Button) playerExitDoor.getDisplayNode();

        double dX;
        double dY;

        switch (moveDirection) {
        case DOWN:
            dX = doorNode.getPrefWidth() / 2 - player.getWidth() / 2;
            dY = -(player.getDisplayNode().getLayoutBounds().getHeight() + 10);
            break;
        case RIGHT:
            dX = -(player.getDisplayNode().getLayoutBounds().getWidth() + 10);
            dY = doorNode.getPrefHeight() / 2 - player.getHeight() / 2;
            break;
        case LEFT:
            dX = 10 + doorNode.getPrefWidth();
            dY = doorNode.getPrefHeight() / 2 - player.getHeight() / 2;
            break;
        case UP:
            dX = doorNode.getPrefWidth() / 2 - player.getWidth() / 2;
            dY = 10 + doorNode.getPrefHeight();
            break;
        default:
            throw new IllegalStateException("Unexpected value: " + moveDirection);
        }

        player.setEntityPosition(dX + doorNode.getTranslateX(),
                                 dY + doorNode.getTranslateY());
    }


    public Player getPlayer() {
        return player;
    }

    public Level getLevel() {
        return level;
    }

    public Room getCurrentRoom() {
        return currentRoom;
    }
}
